// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package kafka_mocks

//go:generate minimock -i github.com/zenmaster911/L0/pkg/kafka_consumer.KafkaReader -o kafka_reader_mock.go -n KafkaReaderMock -p kafka_mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/segmentio/kafka-go"
)

// KafkaReaderMock implements mm_kafkaconsumer.KafkaReader
type KafkaReaderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mKafkaReaderMockClose

	funcFetchMessage          func(ctx context.Context) (m1 kafka.Message, err error)
	funcFetchMessageOrigin    string
	inspectFuncFetchMessage   func(ctx context.Context)
	afterFetchMessageCounter  uint64
	beforeFetchMessageCounter uint64
	FetchMessageMock          mKafkaReaderMockFetchMessage

	funcReadMessage          func(ctx context.Context) (m1 kafka.Message, err error)
	funcReadMessageOrigin    string
	inspectFuncReadMessage   func(ctx context.Context)
	afterReadMessageCounter  uint64
	beforeReadMessageCounter uint64
	ReadMessageMock          mKafkaReaderMockReadMessage
}

// NewKafkaReaderMock returns a mock for mm_kafkaconsumer.KafkaReader
func NewKafkaReaderMock(t minimock.Tester) *KafkaReaderMock {
	m := &KafkaReaderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mKafkaReaderMockClose{mock: m}

	m.FetchMessageMock = mKafkaReaderMockFetchMessage{mock: m}
	m.FetchMessageMock.callArgs = []*KafkaReaderMockFetchMessageParams{}

	m.ReadMessageMock = mKafkaReaderMockReadMessage{mock: m}
	m.ReadMessageMock.callArgs = []*KafkaReaderMockReadMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mKafkaReaderMockClose struct {
	optional           bool
	mock               *KafkaReaderMock
	defaultExpectation *KafkaReaderMockCloseExpectation
	expectations       []*KafkaReaderMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KafkaReaderMockCloseExpectation specifies expectation struct of the KafkaReader.Close
type KafkaReaderMockCloseExpectation struct {
	mock *KafkaReaderMock

	results      *KafkaReaderMockCloseResults
	returnOrigin string
	Counter      uint64
}

// KafkaReaderMockCloseResults contains results of the KafkaReader.Close
type KafkaReaderMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mKafkaReaderMockClose) Optional() *mKafkaReaderMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for KafkaReader.Close
func (mmClose *mKafkaReaderMockClose) Expect() *mKafkaReaderMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("KafkaReaderMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &KafkaReaderMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the KafkaReader.Close
func (mmClose *mKafkaReaderMockClose) Inspect(f func()) *mKafkaReaderMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for KafkaReaderMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by KafkaReader.Close
func (mmClose *mKafkaReaderMockClose) Return(err error) *KafkaReaderMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("KafkaReaderMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &KafkaReaderMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &KafkaReaderMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the KafkaReader.Close method
func (mmClose *mKafkaReaderMockClose) Set(f func() (err error)) *KafkaReaderMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the KafkaReader.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the KafkaReader.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times KafkaReader.Close should be invoked
func (mmClose *mKafkaReaderMockClose) Times(n uint64) *mKafkaReaderMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of KafkaReaderMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mKafkaReaderMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_kafkaconsumer.KafkaReader
func (mmClose *KafkaReaderMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the KafkaReaderMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to KafkaReaderMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished KafkaReaderMock.Close invocations
func (mmClose *KafkaReaderMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of KafkaReaderMock.Close invocations
func (mmClose *KafkaReaderMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *KafkaReaderMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *KafkaReaderMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to KafkaReaderMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to KafkaReaderMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to KafkaReaderMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to KafkaReaderMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mKafkaReaderMockFetchMessage struct {
	optional           bool
	mock               *KafkaReaderMock
	defaultExpectation *KafkaReaderMockFetchMessageExpectation
	expectations       []*KafkaReaderMockFetchMessageExpectation

	callArgs []*KafkaReaderMockFetchMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KafkaReaderMockFetchMessageExpectation specifies expectation struct of the KafkaReader.FetchMessage
type KafkaReaderMockFetchMessageExpectation struct {
	mock               *KafkaReaderMock
	params             *KafkaReaderMockFetchMessageParams
	paramPtrs          *KafkaReaderMockFetchMessageParamPtrs
	expectationOrigins KafkaReaderMockFetchMessageExpectationOrigins
	results            *KafkaReaderMockFetchMessageResults
	returnOrigin       string
	Counter            uint64
}

// KafkaReaderMockFetchMessageParams contains parameters of the KafkaReader.FetchMessage
type KafkaReaderMockFetchMessageParams struct {
	ctx context.Context
}

// KafkaReaderMockFetchMessageParamPtrs contains pointers to parameters of the KafkaReader.FetchMessage
type KafkaReaderMockFetchMessageParamPtrs struct {
	ctx *context.Context
}

// KafkaReaderMockFetchMessageResults contains results of the KafkaReader.FetchMessage
type KafkaReaderMockFetchMessageResults struct {
	m1  kafka.Message
	err error
}

// KafkaReaderMockFetchMessageOrigins contains origins of expectations of the KafkaReader.FetchMessage
type KafkaReaderMockFetchMessageExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFetchMessage *mKafkaReaderMockFetchMessage) Optional() *mKafkaReaderMockFetchMessage {
	mmFetchMessage.optional = true
	return mmFetchMessage
}

// Expect sets up expected params for KafkaReader.FetchMessage
func (mmFetchMessage *mKafkaReaderMockFetchMessage) Expect(ctx context.Context) *mKafkaReaderMockFetchMessage {
	if mmFetchMessage.mock.funcFetchMessage != nil {
		mmFetchMessage.mock.t.Fatalf("KafkaReaderMock.FetchMessage mock is already set by Set")
	}

	if mmFetchMessage.defaultExpectation == nil {
		mmFetchMessage.defaultExpectation = &KafkaReaderMockFetchMessageExpectation{}
	}

	if mmFetchMessage.defaultExpectation.paramPtrs != nil {
		mmFetchMessage.mock.t.Fatalf("KafkaReaderMock.FetchMessage mock is already set by ExpectParams functions")
	}

	mmFetchMessage.defaultExpectation.params = &KafkaReaderMockFetchMessageParams{ctx}
	mmFetchMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFetchMessage.expectations {
		if minimock.Equal(e.params, mmFetchMessage.defaultExpectation.params) {
			mmFetchMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchMessage.defaultExpectation.params)
		}
	}

	return mmFetchMessage
}

// ExpectCtxParam1 sets up expected param ctx for KafkaReader.FetchMessage
func (mmFetchMessage *mKafkaReaderMockFetchMessage) ExpectCtxParam1(ctx context.Context) *mKafkaReaderMockFetchMessage {
	if mmFetchMessage.mock.funcFetchMessage != nil {
		mmFetchMessage.mock.t.Fatalf("KafkaReaderMock.FetchMessage mock is already set by Set")
	}

	if mmFetchMessage.defaultExpectation == nil {
		mmFetchMessage.defaultExpectation = &KafkaReaderMockFetchMessageExpectation{}
	}

	if mmFetchMessage.defaultExpectation.params != nil {
		mmFetchMessage.mock.t.Fatalf("KafkaReaderMock.FetchMessage mock is already set by Expect")
	}

	if mmFetchMessage.defaultExpectation.paramPtrs == nil {
		mmFetchMessage.defaultExpectation.paramPtrs = &KafkaReaderMockFetchMessageParamPtrs{}
	}
	mmFetchMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmFetchMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFetchMessage
}

// Inspect accepts an inspector function that has same arguments as the KafkaReader.FetchMessage
func (mmFetchMessage *mKafkaReaderMockFetchMessage) Inspect(f func(ctx context.Context)) *mKafkaReaderMockFetchMessage {
	if mmFetchMessage.mock.inspectFuncFetchMessage != nil {
		mmFetchMessage.mock.t.Fatalf("Inspect function is already set for KafkaReaderMock.FetchMessage")
	}

	mmFetchMessage.mock.inspectFuncFetchMessage = f

	return mmFetchMessage
}

// Return sets up results that will be returned by KafkaReader.FetchMessage
func (mmFetchMessage *mKafkaReaderMockFetchMessage) Return(m1 kafka.Message, err error) *KafkaReaderMock {
	if mmFetchMessage.mock.funcFetchMessage != nil {
		mmFetchMessage.mock.t.Fatalf("KafkaReaderMock.FetchMessage mock is already set by Set")
	}

	if mmFetchMessage.defaultExpectation == nil {
		mmFetchMessage.defaultExpectation = &KafkaReaderMockFetchMessageExpectation{mock: mmFetchMessage.mock}
	}
	mmFetchMessage.defaultExpectation.results = &KafkaReaderMockFetchMessageResults{m1, err}
	mmFetchMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFetchMessage.mock
}

// Set uses given function f to mock the KafkaReader.FetchMessage method
func (mmFetchMessage *mKafkaReaderMockFetchMessage) Set(f func(ctx context.Context) (m1 kafka.Message, err error)) *KafkaReaderMock {
	if mmFetchMessage.defaultExpectation != nil {
		mmFetchMessage.mock.t.Fatalf("Default expectation is already set for the KafkaReader.FetchMessage method")
	}

	if len(mmFetchMessage.expectations) > 0 {
		mmFetchMessage.mock.t.Fatalf("Some expectations are already set for the KafkaReader.FetchMessage method")
	}

	mmFetchMessage.mock.funcFetchMessage = f
	mmFetchMessage.mock.funcFetchMessageOrigin = minimock.CallerInfo(1)
	return mmFetchMessage.mock
}

// When sets expectation for the KafkaReader.FetchMessage which will trigger the result defined by the following
// Then helper
func (mmFetchMessage *mKafkaReaderMockFetchMessage) When(ctx context.Context) *KafkaReaderMockFetchMessageExpectation {
	if mmFetchMessage.mock.funcFetchMessage != nil {
		mmFetchMessage.mock.t.Fatalf("KafkaReaderMock.FetchMessage mock is already set by Set")
	}

	expectation := &KafkaReaderMockFetchMessageExpectation{
		mock:               mmFetchMessage.mock,
		params:             &KafkaReaderMockFetchMessageParams{ctx},
		expectationOrigins: KafkaReaderMockFetchMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFetchMessage.expectations = append(mmFetchMessage.expectations, expectation)
	return expectation
}

// Then sets up KafkaReader.FetchMessage return parameters for the expectation previously defined by the When method
func (e *KafkaReaderMockFetchMessageExpectation) Then(m1 kafka.Message, err error) *KafkaReaderMock {
	e.results = &KafkaReaderMockFetchMessageResults{m1, err}
	return e.mock
}

// Times sets number of times KafkaReader.FetchMessage should be invoked
func (mmFetchMessage *mKafkaReaderMockFetchMessage) Times(n uint64) *mKafkaReaderMockFetchMessage {
	if n == 0 {
		mmFetchMessage.mock.t.Fatalf("Times of KafkaReaderMock.FetchMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFetchMessage.expectedInvocations, n)
	mmFetchMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFetchMessage
}

func (mmFetchMessage *mKafkaReaderMockFetchMessage) invocationsDone() bool {
	if len(mmFetchMessage.expectations) == 0 && mmFetchMessage.defaultExpectation == nil && mmFetchMessage.mock.funcFetchMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFetchMessage.mock.afterFetchMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFetchMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FetchMessage implements mm_kafkaconsumer.KafkaReader
func (mmFetchMessage *KafkaReaderMock) FetchMessage(ctx context.Context) (m1 kafka.Message, err error) {
	mm_atomic.AddUint64(&mmFetchMessage.beforeFetchMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchMessage.afterFetchMessageCounter, 1)

	mmFetchMessage.t.Helper()

	if mmFetchMessage.inspectFuncFetchMessage != nil {
		mmFetchMessage.inspectFuncFetchMessage(ctx)
	}

	mm_params := KafkaReaderMockFetchMessageParams{ctx}

	// Record call args
	mmFetchMessage.FetchMessageMock.mutex.Lock()
	mmFetchMessage.FetchMessageMock.callArgs = append(mmFetchMessage.FetchMessageMock.callArgs, &mm_params)
	mmFetchMessage.FetchMessageMock.mutex.Unlock()

	for _, e := range mmFetchMessage.FetchMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmFetchMessage.FetchMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchMessage.FetchMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchMessage.FetchMessageMock.defaultExpectation.params
		mm_want_ptrs := mmFetchMessage.FetchMessageMock.defaultExpectation.paramPtrs

		mm_got := KafkaReaderMockFetchMessageParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFetchMessage.t.Errorf("KafkaReaderMock.FetchMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFetchMessage.FetchMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchMessage.t.Errorf("KafkaReaderMock.FetchMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFetchMessage.FetchMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchMessage.FetchMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchMessage.t.Fatal("No results are set for the KafkaReaderMock.FetchMessage")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmFetchMessage.funcFetchMessage != nil {
		return mmFetchMessage.funcFetchMessage(ctx)
	}
	mmFetchMessage.t.Fatalf("Unexpected call to KafkaReaderMock.FetchMessage. %v", ctx)
	return
}

// FetchMessageAfterCounter returns a count of finished KafkaReaderMock.FetchMessage invocations
func (mmFetchMessage *KafkaReaderMock) FetchMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchMessage.afterFetchMessageCounter)
}

// FetchMessageBeforeCounter returns a count of KafkaReaderMock.FetchMessage invocations
func (mmFetchMessage *KafkaReaderMock) FetchMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchMessage.beforeFetchMessageCounter)
}

// Calls returns a list of arguments used in each call to KafkaReaderMock.FetchMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchMessage *mKafkaReaderMockFetchMessage) Calls() []*KafkaReaderMockFetchMessageParams {
	mmFetchMessage.mutex.RLock()

	argCopy := make([]*KafkaReaderMockFetchMessageParams, len(mmFetchMessage.callArgs))
	copy(argCopy, mmFetchMessage.callArgs)

	mmFetchMessage.mutex.RUnlock()

	return argCopy
}

// MinimockFetchMessageDone returns true if the count of the FetchMessage invocations corresponds
// the number of defined expectations
func (m *KafkaReaderMock) MinimockFetchMessageDone() bool {
	if m.FetchMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FetchMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FetchMessageMock.invocationsDone()
}

// MinimockFetchMessageInspect logs each unmet expectation
func (m *KafkaReaderMock) MinimockFetchMessageInspect() {
	for _, e := range m.FetchMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KafkaReaderMock.FetchMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFetchMessageCounter := mm_atomic.LoadUint64(&m.afterFetchMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FetchMessageMock.defaultExpectation != nil && afterFetchMessageCounter < 1 {
		if m.FetchMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KafkaReaderMock.FetchMessage at\n%s", m.FetchMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KafkaReaderMock.FetchMessage at\n%s with params: %#v", m.FetchMessageMock.defaultExpectation.expectationOrigins.origin, *m.FetchMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchMessage != nil && afterFetchMessageCounter < 1 {
		m.t.Errorf("Expected call to KafkaReaderMock.FetchMessage at\n%s", m.funcFetchMessageOrigin)
	}

	if !m.FetchMessageMock.invocationsDone() && afterFetchMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to KafkaReaderMock.FetchMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FetchMessageMock.expectedInvocations), m.FetchMessageMock.expectedInvocationsOrigin, afterFetchMessageCounter)
	}
}

type mKafkaReaderMockReadMessage struct {
	optional           bool
	mock               *KafkaReaderMock
	defaultExpectation *KafkaReaderMockReadMessageExpectation
	expectations       []*KafkaReaderMockReadMessageExpectation

	callArgs []*KafkaReaderMockReadMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KafkaReaderMockReadMessageExpectation specifies expectation struct of the KafkaReader.ReadMessage
type KafkaReaderMockReadMessageExpectation struct {
	mock               *KafkaReaderMock
	params             *KafkaReaderMockReadMessageParams
	paramPtrs          *KafkaReaderMockReadMessageParamPtrs
	expectationOrigins KafkaReaderMockReadMessageExpectationOrigins
	results            *KafkaReaderMockReadMessageResults
	returnOrigin       string
	Counter            uint64
}

// KafkaReaderMockReadMessageParams contains parameters of the KafkaReader.ReadMessage
type KafkaReaderMockReadMessageParams struct {
	ctx context.Context
}

// KafkaReaderMockReadMessageParamPtrs contains pointers to parameters of the KafkaReader.ReadMessage
type KafkaReaderMockReadMessageParamPtrs struct {
	ctx *context.Context
}

// KafkaReaderMockReadMessageResults contains results of the KafkaReader.ReadMessage
type KafkaReaderMockReadMessageResults struct {
	m1  kafka.Message
	err error
}

// KafkaReaderMockReadMessageOrigins contains origins of expectations of the KafkaReader.ReadMessage
type KafkaReaderMockReadMessageExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadMessage *mKafkaReaderMockReadMessage) Optional() *mKafkaReaderMockReadMessage {
	mmReadMessage.optional = true
	return mmReadMessage
}

// Expect sets up expected params for KafkaReader.ReadMessage
func (mmReadMessage *mKafkaReaderMockReadMessage) Expect(ctx context.Context) *mKafkaReaderMockReadMessage {
	if mmReadMessage.mock.funcReadMessage != nil {
		mmReadMessage.mock.t.Fatalf("KafkaReaderMock.ReadMessage mock is already set by Set")
	}

	if mmReadMessage.defaultExpectation == nil {
		mmReadMessage.defaultExpectation = &KafkaReaderMockReadMessageExpectation{}
	}

	if mmReadMessage.defaultExpectation.paramPtrs != nil {
		mmReadMessage.mock.t.Fatalf("KafkaReaderMock.ReadMessage mock is already set by ExpectParams functions")
	}

	mmReadMessage.defaultExpectation.params = &KafkaReaderMockReadMessageParams{ctx}
	mmReadMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadMessage.expectations {
		if minimock.Equal(e.params, mmReadMessage.defaultExpectation.params) {
			mmReadMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadMessage.defaultExpectation.params)
		}
	}

	return mmReadMessage
}

// ExpectCtxParam1 sets up expected param ctx for KafkaReader.ReadMessage
func (mmReadMessage *mKafkaReaderMockReadMessage) ExpectCtxParam1(ctx context.Context) *mKafkaReaderMockReadMessage {
	if mmReadMessage.mock.funcReadMessage != nil {
		mmReadMessage.mock.t.Fatalf("KafkaReaderMock.ReadMessage mock is already set by Set")
	}

	if mmReadMessage.defaultExpectation == nil {
		mmReadMessage.defaultExpectation = &KafkaReaderMockReadMessageExpectation{}
	}

	if mmReadMessage.defaultExpectation.params != nil {
		mmReadMessage.mock.t.Fatalf("KafkaReaderMock.ReadMessage mock is already set by Expect")
	}

	if mmReadMessage.defaultExpectation.paramPtrs == nil {
		mmReadMessage.defaultExpectation.paramPtrs = &KafkaReaderMockReadMessageParamPtrs{}
	}
	mmReadMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadMessage
}

// Inspect accepts an inspector function that has same arguments as the KafkaReader.ReadMessage
func (mmReadMessage *mKafkaReaderMockReadMessage) Inspect(f func(ctx context.Context)) *mKafkaReaderMockReadMessage {
	if mmReadMessage.mock.inspectFuncReadMessage != nil {
		mmReadMessage.mock.t.Fatalf("Inspect function is already set for KafkaReaderMock.ReadMessage")
	}

	mmReadMessage.mock.inspectFuncReadMessage = f

	return mmReadMessage
}

// Return sets up results that will be returned by KafkaReader.ReadMessage
func (mmReadMessage *mKafkaReaderMockReadMessage) Return(m1 kafka.Message, err error) *KafkaReaderMock {
	if mmReadMessage.mock.funcReadMessage != nil {
		mmReadMessage.mock.t.Fatalf("KafkaReaderMock.ReadMessage mock is already set by Set")
	}

	if mmReadMessage.defaultExpectation == nil {
		mmReadMessage.defaultExpectation = &KafkaReaderMockReadMessageExpectation{mock: mmReadMessage.mock}
	}
	mmReadMessage.defaultExpectation.results = &KafkaReaderMockReadMessageResults{m1, err}
	mmReadMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadMessage.mock
}

// Set uses given function f to mock the KafkaReader.ReadMessage method
func (mmReadMessage *mKafkaReaderMockReadMessage) Set(f func(ctx context.Context) (m1 kafka.Message, err error)) *KafkaReaderMock {
	if mmReadMessage.defaultExpectation != nil {
		mmReadMessage.mock.t.Fatalf("Default expectation is already set for the KafkaReader.ReadMessage method")
	}

	if len(mmReadMessage.expectations) > 0 {
		mmReadMessage.mock.t.Fatalf("Some expectations are already set for the KafkaReader.ReadMessage method")
	}

	mmReadMessage.mock.funcReadMessage = f
	mmReadMessage.mock.funcReadMessageOrigin = minimock.CallerInfo(1)
	return mmReadMessage.mock
}

// When sets expectation for the KafkaReader.ReadMessage which will trigger the result defined by the following
// Then helper
func (mmReadMessage *mKafkaReaderMockReadMessage) When(ctx context.Context) *KafkaReaderMockReadMessageExpectation {
	if mmReadMessage.mock.funcReadMessage != nil {
		mmReadMessage.mock.t.Fatalf("KafkaReaderMock.ReadMessage mock is already set by Set")
	}

	expectation := &KafkaReaderMockReadMessageExpectation{
		mock:               mmReadMessage.mock,
		params:             &KafkaReaderMockReadMessageParams{ctx},
		expectationOrigins: KafkaReaderMockReadMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadMessage.expectations = append(mmReadMessage.expectations, expectation)
	return expectation
}

// Then sets up KafkaReader.ReadMessage return parameters for the expectation previously defined by the When method
func (e *KafkaReaderMockReadMessageExpectation) Then(m1 kafka.Message, err error) *KafkaReaderMock {
	e.results = &KafkaReaderMockReadMessageResults{m1, err}
	return e.mock
}

// Times sets number of times KafkaReader.ReadMessage should be invoked
func (mmReadMessage *mKafkaReaderMockReadMessage) Times(n uint64) *mKafkaReaderMockReadMessage {
	if n == 0 {
		mmReadMessage.mock.t.Fatalf("Times of KafkaReaderMock.ReadMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadMessage.expectedInvocations, n)
	mmReadMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadMessage
}

func (mmReadMessage *mKafkaReaderMockReadMessage) invocationsDone() bool {
	if len(mmReadMessage.expectations) == 0 && mmReadMessage.defaultExpectation == nil && mmReadMessage.mock.funcReadMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadMessage.mock.afterReadMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadMessage implements mm_kafkaconsumer.KafkaReader
func (mmReadMessage *KafkaReaderMock) ReadMessage(ctx context.Context) (m1 kafka.Message, err error) {
	mm_atomic.AddUint64(&mmReadMessage.beforeReadMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmReadMessage.afterReadMessageCounter, 1)

	mmReadMessage.t.Helper()

	if mmReadMessage.inspectFuncReadMessage != nil {
		mmReadMessage.inspectFuncReadMessage(ctx)
	}

	mm_params := KafkaReaderMockReadMessageParams{ctx}

	// Record call args
	mmReadMessage.ReadMessageMock.mutex.Lock()
	mmReadMessage.ReadMessageMock.callArgs = append(mmReadMessage.ReadMessageMock.callArgs, &mm_params)
	mmReadMessage.ReadMessageMock.mutex.Unlock()

	for _, e := range mmReadMessage.ReadMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmReadMessage.ReadMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadMessage.ReadMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmReadMessage.ReadMessageMock.defaultExpectation.params
		mm_want_ptrs := mmReadMessage.ReadMessageMock.defaultExpectation.paramPtrs

		mm_got := KafkaReaderMockReadMessageParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadMessage.t.Errorf("KafkaReaderMock.ReadMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadMessage.ReadMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadMessage.t.Errorf("KafkaReaderMock.ReadMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadMessage.ReadMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadMessage.ReadMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmReadMessage.t.Fatal("No results are set for the KafkaReaderMock.ReadMessage")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmReadMessage.funcReadMessage != nil {
		return mmReadMessage.funcReadMessage(ctx)
	}
	mmReadMessage.t.Fatalf("Unexpected call to KafkaReaderMock.ReadMessage. %v", ctx)
	return
}

// ReadMessageAfterCounter returns a count of finished KafkaReaderMock.ReadMessage invocations
func (mmReadMessage *KafkaReaderMock) ReadMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadMessage.afterReadMessageCounter)
}

// ReadMessageBeforeCounter returns a count of KafkaReaderMock.ReadMessage invocations
func (mmReadMessage *KafkaReaderMock) ReadMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadMessage.beforeReadMessageCounter)
}

// Calls returns a list of arguments used in each call to KafkaReaderMock.ReadMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadMessage *mKafkaReaderMockReadMessage) Calls() []*KafkaReaderMockReadMessageParams {
	mmReadMessage.mutex.RLock()

	argCopy := make([]*KafkaReaderMockReadMessageParams, len(mmReadMessage.callArgs))
	copy(argCopy, mmReadMessage.callArgs)

	mmReadMessage.mutex.RUnlock()

	return argCopy
}

// MinimockReadMessageDone returns true if the count of the ReadMessage invocations corresponds
// the number of defined expectations
func (m *KafkaReaderMock) MinimockReadMessageDone() bool {
	if m.ReadMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadMessageMock.invocationsDone()
}

// MinimockReadMessageInspect logs each unmet expectation
func (m *KafkaReaderMock) MinimockReadMessageInspect() {
	for _, e := range m.ReadMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KafkaReaderMock.ReadMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadMessageCounter := mm_atomic.LoadUint64(&m.afterReadMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMessageMock.defaultExpectation != nil && afterReadMessageCounter < 1 {
		if m.ReadMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KafkaReaderMock.ReadMessage at\n%s", m.ReadMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KafkaReaderMock.ReadMessage at\n%s with params: %#v", m.ReadMessageMock.defaultExpectation.expectationOrigins.origin, *m.ReadMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadMessage != nil && afterReadMessageCounter < 1 {
		m.t.Errorf("Expected call to KafkaReaderMock.ReadMessage at\n%s", m.funcReadMessageOrigin)
	}

	if !m.ReadMessageMock.invocationsDone() && afterReadMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to KafkaReaderMock.ReadMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadMessageMock.expectedInvocations), m.ReadMessageMock.expectedInvocationsOrigin, afterReadMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *KafkaReaderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockFetchMessageInspect()

			m.MinimockReadMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *KafkaReaderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *KafkaReaderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockFetchMessageDone() &&
		m.MinimockReadMessageDone()
}
