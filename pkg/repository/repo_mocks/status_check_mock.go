// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package repo_mocks

//go:generate minimock -i github.com/zenmaster911/L0/pkg/repository.StatusCheck -o status_check_mock.go -n StatusCheckMock -p repo_mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StatusCheckMock implements mm_repository.StatusCheck
type StatusCheckMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDBConnectionCheck          func() (err error)
	funcDBConnectionCheckOrigin    string
	inspectFuncDBConnectionCheck   func()
	afterDBConnectionCheckCounter  uint64
	beforeDBConnectionCheckCounter uint64
	DBConnectionCheckMock          mStatusCheckMockDBConnectionCheck
}

// NewStatusCheckMock returns a mock for mm_repository.StatusCheck
func NewStatusCheckMock(t minimock.Tester) *StatusCheckMock {
	m := &StatusCheckMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DBConnectionCheckMock = mStatusCheckMockDBConnectionCheck{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStatusCheckMockDBConnectionCheck struct {
	optional           bool
	mock               *StatusCheckMock
	defaultExpectation *StatusCheckMockDBConnectionCheckExpectation
	expectations       []*StatusCheckMockDBConnectionCheckExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StatusCheckMockDBConnectionCheckExpectation specifies expectation struct of the StatusCheck.DBConnectionCheck
type StatusCheckMockDBConnectionCheckExpectation struct {
	mock *StatusCheckMock

	results      *StatusCheckMockDBConnectionCheckResults
	returnOrigin string
	Counter      uint64
}

// StatusCheckMockDBConnectionCheckResults contains results of the StatusCheck.DBConnectionCheck
type StatusCheckMockDBConnectionCheckResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDBConnectionCheck *mStatusCheckMockDBConnectionCheck) Optional() *mStatusCheckMockDBConnectionCheck {
	mmDBConnectionCheck.optional = true
	return mmDBConnectionCheck
}

// Expect sets up expected params for StatusCheck.DBConnectionCheck
func (mmDBConnectionCheck *mStatusCheckMockDBConnectionCheck) Expect() *mStatusCheckMockDBConnectionCheck {
	if mmDBConnectionCheck.mock.funcDBConnectionCheck != nil {
		mmDBConnectionCheck.mock.t.Fatalf("StatusCheckMock.DBConnectionCheck mock is already set by Set")
	}

	if mmDBConnectionCheck.defaultExpectation == nil {
		mmDBConnectionCheck.defaultExpectation = &StatusCheckMockDBConnectionCheckExpectation{}
	}

	return mmDBConnectionCheck
}

// Inspect accepts an inspector function that has same arguments as the StatusCheck.DBConnectionCheck
func (mmDBConnectionCheck *mStatusCheckMockDBConnectionCheck) Inspect(f func()) *mStatusCheckMockDBConnectionCheck {
	if mmDBConnectionCheck.mock.inspectFuncDBConnectionCheck != nil {
		mmDBConnectionCheck.mock.t.Fatalf("Inspect function is already set for StatusCheckMock.DBConnectionCheck")
	}

	mmDBConnectionCheck.mock.inspectFuncDBConnectionCheck = f

	return mmDBConnectionCheck
}

// Return sets up results that will be returned by StatusCheck.DBConnectionCheck
func (mmDBConnectionCheck *mStatusCheckMockDBConnectionCheck) Return(err error) *StatusCheckMock {
	if mmDBConnectionCheck.mock.funcDBConnectionCheck != nil {
		mmDBConnectionCheck.mock.t.Fatalf("StatusCheckMock.DBConnectionCheck mock is already set by Set")
	}

	if mmDBConnectionCheck.defaultExpectation == nil {
		mmDBConnectionCheck.defaultExpectation = &StatusCheckMockDBConnectionCheckExpectation{mock: mmDBConnectionCheck.mock}
	}
	mmDBConnectionCheck.defaultExpectation.results = &StatusCheckMockDBConnectionCheckResults{err}
	mmDBConnectionCheck.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDBConnectionCheck.mock
}

// Set uses given function f to mock the StatusCheck.DBConnectionCheck method
func (mmDBConnectionCheck *mStatusCheckMockDBConnectionCheck) Set(f func() (err error)) *StatusCheckMock {
	if mmDBConnectionCheck.defaultExpectation != nil {
		mmDBConnectionCheck.mock.t.Fatalf("Default expectation is already set for the StatusCheck.DBConnectionCheck method")
	}

	if len(mmDBConnectionCheck.expectations) > 0 {
		mmDBConnectionCheck.mock.t.Fatalf("Some expectations are already set for the StatusCheck.DBConnectionCheck method")
	}

	mmDBConnectionCheck.mock.funcDBConnectionCheck = f
	mmDBConnectionCheck.mock.funcDBConnectionCheckOrigin = minimock.CallerInfo(1)
	return mmDBConnectionCheck.mock
}

// Times sets number of times StatusCheck.DBConnectionCheck should be invoked
func (mmDBConnectionCheck *mStatusCheckMockDBConnectionCheck) Times(n uint64) *mStatusCheckMockDBConnectionCheck {
	if n == 0 {
		mmDBConnectionCheck.mock.t.Fatalf("Times of StatusCheckMock.DBConnectionCheck mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDBConnectionCheck.expectedInvocations, n)
	mmDBConnectionCheck.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDBConnectionCheck
}

func (mmDBConnectionCheck *mStatusCheckMockDBConnectionCheck) invocationsDone() bool {
	if len(mmDBConnectionCheck.expectations) == 0 && mmDBConnectionCheck.defaultExpectation == nil && mmDBConnectionCheck.mock.funcDBConnectionCheck == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDBConnectionCheck.mock.afterDBConnectionCheckCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDBConnectionCheck.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DBConnectionCheck implements mm_repository.StatusCheck
func (mmDBConnectionCheck *StatusCheckMock) DBConnectionCheck() (err error) {
	mm_atomic.AddUint64(&mmDBConnectionCheck.beforeDBConnectionCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmDBConnectionCheck.afterDBConnectionCheckCounter, 1)

	mmDBConnectionCheck.t.Helper()

	if mmDBConnectionCheck.inspectFuncDBConnectionCheck != nil {
		mmDBConnectionCheck.inspectFuncDBConnectionCheck()
	}

	if mmDBConnectionCheck.DBConnectionCheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDBConnectionCheck.DBConnectionCheckMock.defaultExpectation.Counter, 1)

		mm_results := mmDBConnectionCheck.DBConnectionCheckMock.defaultExpectation.results
		if mm_results == nil {
			mmDBConnectionCheck.t.Fatal("No results are set for the StatusCheckMock.DBConnectionCheck")
		}
		return (*mm_results).err
	}
	if mmDBConnectionCheck.funcDBConnectionCheck != nil {
		return mmDBConnectionCheck.funcDBConnectionCheck()
	}
	mmDBConnectionCheck.t.Fatalf("Unexpected call to StatusCheckMock.DBConnectionCheck.")
	return
}

// DBConnectionCheckAfterCounter returns a count of finished StatusCheckMock.DBConnectionCheck invocations
func (mmDBConnectionCheck *StatusCheckMock) DBConnectionCheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDBConnectionCheck.afterDBConnectionCheckCounter)
}

// DBConnectionCheckBeforeCounter returns a count of StatusCheckMock.DBConnectionCheck invocations
func (mmDBConnectionCheck *StatusCheckMock) DBConnectionCheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDBConnectionCheck.beforeDBConnectionCheckCounter)
}

// MinimockDBConnectionCheckDone returns true if the count of the DBConnectionCheck invocations corresponds
// the number of defined expectations
func (m *StatusCheckMock) MinimockDBConnectionCheckDone() bool {
	if m.DBConnectionCheckMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DBConnectionCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DBConnectionCheckMock.invocationsDone()
}

// MinimockDBConnectionCheckInspect logs each unmet expectation
func (m *StatusCheckMock) MinimockDBConnectionCheckInspect() {
	for _, e := range m.DBConnectionCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StatusCheckMock.DBConnectionCheck")
		}
	}

	afterDBConnectionCheckCounter := mm_atomic.LoadUint64(&m.afterDBConnectionCheckCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DBConnectionCheckMock.defaultExpectation != nil && afterDBConnectionCheckCounter < 1 {
		m.t.Errorf("Expected call to StatusCheckMock.DBConnectionCheck at\n%s", m.DBConnectionCheckMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDBConnectionCheck != nil && afterDBConnectionCheckCounter < 1 {
		m.t.Errorf("Expected call to StatusCheckMock.DBConnectionCheck at\n%s", m.funcDBConnectionCheckOrigin)
	}

	if !m.DBConnectionCheckMock.invocationsDone() && afterDBConnectionCheckCounter > 0 {
		m.t.Errorf("Expected %d calls to StatusCheckMock.DBConnectionCheck at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DBConnectionCheckMock.expectedInvocations), m.DBConnectionCheckMock.expectedInvocationsOrigin, afterDBConnectionCheckCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StatusCheckMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDBConnectionCheckInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StatusCheckMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StatusCheckMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDBConnectionCheckDone()
}
