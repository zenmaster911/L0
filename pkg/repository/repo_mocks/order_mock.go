// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package repo_mocks

//go:generate minimock -i github.com/zenmaster911/L0/pkg/repository.Order -o order_mock.go -n OrderMock -p repo_mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/zenmaster911/L0/pkg/model"
)

// OrderMock implements mm_repository.Order
type OrderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckOrderExists          func(uid string) (b1 bool, err error)
	funcCheckOrderExistsOrigin    string
	inspectFuncCheckOrderExists   func(uid string)
	afterCheckOrderExistsCounter  uint64
	beforeCheckOrderExistsCounter uint64
	CheckOrderExistsMock          mOrderMockCheckOrderExists

	funcCreateOrder          func(input *model.Reply) (uid string, err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(input *model.Reply)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mOrderMockCreateOrder

	funcGetOrderByUid          func(uid string) (r1 model.Reply, err error)
	funcGetOrderByUidOrigin    string
	inspectFuncGetOrderByUid   func(uid string)
	afterGetOrderByUidCounter  uint64
	beforeGetOrderByUidCounter uint64
	GetOrderByUidMock          mOrderMockGetOrderByUid
}

// NewOrderMock returns a mock for mm_repository.Order
func NewOrderMock(t minimock.Tester) *OrderMock {
	m := &OrderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckOrderExistsMock = mOrderMockCheckOrderExists{mock: m}
	m.CheckOrderExistsMock.callArgs = []*OrderMockCheckOrderExistsParams{}

	m.CreateOrderMock = mOrderMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*OrderMockCreateOrderParams{}

	m.GetOrderByUidMock = mOrderMockGetOrderByUid{mock: m}
	m.GetOrderByUidMock.callArgs = []*OrderMockGetOrderByUidParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderMockCheckOrderExists struct {
	optional           bool
	mock               *OrderMock
	defaultExpectation *OrderMockCheckOrderExistsExpectation
	expectations       []*OrderMockCheckOrderExistsExpectation

	callArgs []*OrderMockCheckOrderExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderMockCheckOrderExistsExpectation specifies expectation struct of the Order.CheckOrderExists
type OrderMockCheckOrderExistsExpectation struct {
	mock               *OrderMock
	params             *OrderMockCheckOrderExistsParams
	paramPtrs          *OrderMockCheckOrderExistsParamPtrs
	expectationOrigins OrderMockCheckOrderExistsExpectationOrigins
	results            *OrderMockCheckOrderExistsResults
	returnOrigin       string
	Counter            uint64
}

// OrderMockCheckOrderExistsParams contains parameters of the Order.CheckOrderExists
type OrderMockCheckOrderExistsParams struct {
	uid string
}

// OrderMockCheckOrderExistsParamPtrs contains pointers to parameters of the Order.CheckOrderExists
type OrderMockCheckOrderExistsParamPtrs struct {
	uid *string
}

// OrderMockCheckOrderExistsResults contains results of the Order.CheckOrderExists
type OrderMockCheckOrderExistsResults struct {
	b1  bool
	err error
}

// OrderMockCheckOrderExistsOrigins contains origins of expectations of the Order.CheckOrderExists
type OrderMockCheckOrderExistsExpectationOrigins struct {
	origin    string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckOrderExists *mOrderMockCheckOrderExists) Optional() *mOrderMockCheckOrderExists {
	mmCheckOrderExists.optional = true
	return mmCheckOrderExists
}

// Expect sets up expected params for Order.CheckOrderExists
func (mmCheckOrderExists *mOrderMockCheckOrderExists) Expect(uid string) *mOrderMockCheckOrderExists {
	if mmCheckOrderExists.mock.funcCheckOrderExists != nil {
		mmCheckOrderExists.mock.t.Fatalf("OrderMock.CheckOrderExists mock is already set by Set")
	}

	if mmCheckOrderExists.defaultExpectation == nil {
		mmCheckOrderExists.defaultExpectation = &OrderMockCheckOrderExistsExpectation{}
	}

	if mmCheckOrderExists.defaultExpectation.paramPtrs != nil {
		mmCheckOrderExists.mock.t.Fatalf("OrderMock.CheckOrderExists mock is already set by ExpectParams functions")
	}

	mmCheckOrderExists.defaultExpectation.params = &OrderMockCheckOrderExistsParams{uid}
	mmCheckOrderExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckOrderExists.expectations {
		if minimock.Equal(e.params, mmCheckOrderExists.defaultExpectation.params) {
			mmCheckOrderExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckOrderExists.defaultExpectation.params)
		}
	}

	return mmCheckOrderExists
}

// ExpectUidParam1 sets up expected param uid for Order.CheckOrderExists
func (mmCheckOrderExists *mOrderMockCheckOrderExists) ExpectUidParam1(uid string) *mOrderMockCheckOrderExists {
	if mmCheckOrderExists.mock.funcCheckOrderExists != nil {
		mmCheckOrderExists.mock.t.Fatalf("OrderMock.CheckOrderExists mock is already set by Set")
	}

	if mmCheckOrderExists.defaultExpectation == nil {
		mmCheckOrderExists.defaultExpectation = &OrderMockCheckOrderExistsExpectation{}
	}

	if mmCheckOrderExists.defaultExpectation.params != nil {
		mmCheckOrderExists.mock.t.Fatalf("OrderMock.CheckOrderExists mock is already set by Expect")
	}

	if mmCheckOrderExists.defaultExpectation.paramPtrs == nil {
		mmCheckOrderExists.defaultExpectation.paramPtrs = &OrderMockCheckOrderExistsParamPtrs{}
	}
	mmCheckOrderExists.defaultExpectation.paramPtrs.uid = &uid
	mmCheckOrderExists.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmCheckOrderExists
}

// Inspect accepts an inspector function that has same arguments as the Order.CheckOrderExists
func (mmCheckOrderExists *mOrderMockCheckOrderExists) Inspect(f func(uid string)) *mOrderMockCheckOrderExists {
	if mmCheckOrderExists.mock.inspectFuncCheckOrderExists != nil {
		mmCheckOrderExists.mock.t.Fatalf("Inspect function is already set for OrderMock.CheckOrderExists")
	}

	mmCheckOrderExists.mock.inspectFuncCheckOrderExists = f

	return mmCheckOrderExists
}

// Return sets up results that will be returned by Order.CheckOrderExists
func (mmCheckOrderExists *mOrderMockCheckOrderExists) Return(b1 bool, err error) *OrderMock {
	if mmCheckOrderExists.mock.funcCheckOrderExists != nil {
		mmCheckOrderExists.mock.t.Fatalf("OrderMock.CheckOrderExists mock is already set by Set")
	}

	if mmCheckOrderExists.defaultExpectation == nil {
		mmCheckOrderExists.defaultExpectation = &OrderMockCheckOrderExistsExpectation{mock: mmCheckOrderExists.mock}
	}
	mmCheckOrderExists.defaultExpectation.results = &OrderMockCheckOrderExistsResults{b1, err}
	mmCheckOrderExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckOrderExists.mock
}

// Set uses given function f to mock the Order.CheckOrderExists method
func (mmCheckOrderExists *mOrderMockCheckOrderExists) Set(f func(uid string) (b1 bool, err error)) *OrderMock {
	if mmCheckOrderExists.defaultExpectation != nil {
		mmCheckOrderExists.mock.t.Fatalf("Default expectation is already set for the Order.CheckOrderExists method")
	}

	if len(mmCheckOrderExists.expectations) > 0 {
		mmCheckOrderExists.mock.t.Fatalf("Some expectations are already set for the Order.CheckOrderExists method")
	}

	mmCheckOrderExists.mock.funcCheckOrderExists = f
	mmCheckOrderExists.mock.funcCheckOrderExistsOrigin = minimock.CallerInfo(1)
	return mmCheckOrderExists.mock
}

// When sets expectation for the Order.CheckOrderExists which will trigger the result defined by the following
// Then helper
func (mmCheckOrderExists *mOrderMockCheckOrderExists) When(uid string) *OrderMockCheckOrderExistsExpectation {
	if mmCheckOrderExists.mock.funcCheckOrderExists != nil {
		mmCheckOrderExists.mock.t.Fatalf("OrderMock.CheckOrderExists mock is already set by Set")
	}

	expectation := &OrderMockCheckOrderExistsExpectation{
		mock:               mmCheckOrderExists.mock,
		params:             &OrderMockCheckOrderExistsParams{uid},
		expectationOrigins: OrderMockCheckOrderExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckOrderExists.expectations = append(mmCheckOrderExists.expectations, expectation)
	return expectation
}

// Then sets up Order.CheckOrderExists return parameters for the expectation previously defined by the When method
func (e *OrderMockCheckOrderExistsExpectation) Then(b1 bool, err error) *OrderMock {
	e.results = &OrderMockCheckOrderExistsResults{b1, err}
	return e.mock
}

// Times sets number of times Order.CheckOrderExists should be invoked
func (mmCheckOrderExists *mOrderMockCheckOrderExists) Times(n uint64) *mOrderMockCheckOrderExists {
	if n == 0 {
		mmCheckOrderExists.mock.t.Fatalf("Times of OrderMock.CheckOrderExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckOrderExists.expectedInvocations, n)
	mmCheckOrderExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckOrderExists
}

func (mmCheckOrderExists *mOrderMockCheckOrderExists) invocationsDone() bool {
	if len(mmCheckOrderExists.expectations) == 0 && mmCheckOrderExists.defaultExpectation == nil && mmCheckOrderExists.mock.funcCheckOrderExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckOrderExists.mock.afterCheckOrderExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckOrderExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckOrderExists implements mm_repository.Order
func (mmCheckOrderExists *OrderMock) CheckOrderExists(uid string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckOrderExists.beforeCheckOrderExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckOrderExists.afterCheckOrderExistsCounter, 1)

	mmCheckOrderExists.t.Helper()

	if mmCheckOrderExists.inspectFuncCheckOrderExists != nil {
		mmCheckOrderExists.inspectFuncCheckOrderExists(uid)
	}

	mm_params := OrderMockCheckOrderExistsParams{uid}

	// Record call args
	mmCheckOrderExists.CheckOrderExistsMock.mutex.Lock()
	mmCheckOrderExists.CheckOrderExistsMock.callArgs = append(mmCheckOrderExists.CheckOrderExistsMock.callArgs, &mm_params)
	mmCheckOrderExists.CheckOrderExistsMock.mutex.Unlock()

	for _, e := range mmCheckOrderExists.CheckOrderExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckOrderExists.CheckOrderExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckOrderExists.CheckOrderExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckOrderExists.CheckOrderExistsMock.defaultExpectation.params
		mm_want_ptrs := mmCheckOrderExists.CheckOrderExistsMock.defaultExpectation.paramPtrs

		mm_got := OrderMockCheckOrderExistsParams{uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmCheckOrderExists.t.Errorf("OrderMock.CheckOrderExists got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckOrderExists.CheckOrderExistsMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckOrderExists.t.Errorf("OrderMock.CheckOrderExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckOrderExists.CheckOrderExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckOrderExists.CheckOrderExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckOrderExists.t.Fatal("No results are set for the OrderMock.CheckOrderExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckOrderExists.funcCheckOrderExists != nil {
		return mmCheckOrderExists.funcCheckOrderExists(uid)
	}
	mmCheckOrderExists.t.Fatalf("Unexpected call to OrderMock.CheckOrderExists. %v", uid)
	return
}

// CheckOrderExistsAfterCounter returns a count of finished OrderMock.CheckOrderExists invocations
func (mmCheckOrderExists *OrderMock) CheckOrderExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckOrderExists.afterCheckOrderExistsCounter)
}

// CheckOrderExistsBeforeCounter returns a count of OrderMock.CheckOrderExists invocations
func (mmCheckOrderExists *OrderMock) CheckOrderExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckOrderExists.beforeCheckOrderExistsCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.CheckOrderExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckOrderExists *mOrderMockCheckOrderExists) Calls() []*OrderMockCheckOrderExistsParams {
	mmCheckOrderExists.mutex.RLock()

	argCopy := make([]*OrderMockCheckOrderExistsParams, len(mmCheckOrderExists.callArgs))
	copy(argCopy, mmCheckOrderExists.callArgs)

	mmCheckOrderExists.mutex.RUnlock()

	return argCopy
}

// MinimockCheckOrderExistsDone returns true if the count of the CheckOrderExists invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockCheckOrderExistsDone() bool {
	if m.CheckOrderExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckOrderExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckOrderExistsMock.invocationsDone()
}

// MinimockCheckOrderExistsInspect logs each unmet expectation
func (m *OrderMock) MinimockCheckOrderExistsInspect() {
	for _, e := range m.CheckOrderExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.CheckOrderExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckOrderExistsCounter := mm_atomic.LoadUint64(&m.afterCheckOrderExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckOrderExistsMock.defaultExpectation != nil && afterCheckOrderExistsCounter < 1 {
		if m.CheckOrderExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderMock.CheckOrderExists at\n%s", m.CheckOrderExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderMock.CheckOrderExists at\n%s with params: %#v", m.CheckOrderExistsMock.defaultExpectation.expectationOrigins.origin, *m.CheckOrderExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckOrderExists != nil && afterCheckOrderExistsCounter < 1 {
		m.t.Errorf("Expected call to OrderMock.CheckOrderExists at\n%s", m.funcCheckOrderExistsOrigin)
	}

	if !m.CheckOrderExistsMock.invocationsDone() && afterCheckOrderExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderMock.CheckOrderExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckOrderExistsMock.expectedInvocations), m.CheckOrderExistsMock.expectedInvocationsOrigin, afterCheckOrderExistsCounter)
	}
}

type mOrderMockCreateOrder struct {
	optional           bool
	mock               *OrderMock
	defaultExpectation *OrderMockCreateOrderExpectation
	expectations       []*OrderMockCreateOrderExpectation

	callArgs []*OrderMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderMockCreateOrderExpectation specifies expectation struct of the Order.CreateOrder
type OrderMockCreateOrderExpectation struct {
	mock               *OrderMock
	params             *OrderMockCreateOrderParams
	paramPtrs          *OrderMockCreateOrderParamPtrs
	expectationOrigins OrderMockCreateOrderExpectationOrigins
	results            *OrderMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderMockCreateOrderParams contains parameters of the Order.CreateOrder
type OrderMockCreateOrderParams struct {
	input *model.Reply
}

// OrderMockCreateOrderParamPtrs contains pointers to parameters of the Order.CreateOrder
type OrderMockCreateOrderParamPtrs struct {
	input **model.Reply
}

// OrderMockCreateOrderResults contains results of the Order.CreateOrder
type OrderMockCreateOrderResults struct {
	uid string
	err error
}

// OrderMockCreateOrderOrigins contains origins of expectations of the Order.CreateOrder
type OrderMockCreateOrderExpectationOrigins struct {
	origin      string
	originInput string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mOrderMockCreateOrder) Optional() *mOrderMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for Order.CreateOrder
func (mmCreateOrder *mOrderMockCreateOrder) Expect(input *model.Reply) *mOrderMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &OrderMockCreateOrderParams{input}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectInputParam1 sets up expected param input for Order.CreateOrder
func (mmCreateOrder *mOrderMockCreateOrder) ExpectInputParam1(input *model.Reply) *mOrderMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &OrderMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.input = &input
	mmCreateOrder.defaultExpectation.expectationOrigins.originInput = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Order.CreateOrder
func (mmCreateOrder *mOrderMockCreateOrder) Inspect(f func(input *model.Reply)) *mOrderMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for OrderMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Order.CreateOrder
func (mmCreateOrder *mOrderMockCreateOrder) Return(uid string, err error) *OrderMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &OrderMockCreateOrderResults{uid, err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Order.CreateOrder method
func (mmCreateOrder *mOrderMockCreateOrder) Set(f func(input *model.Reply) (uid string, err error)) *OrderMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Order.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Order.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the Order.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mOrderMockCreateOrder) When(input *model.Reply) *OrderMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Set")
	}

	expectation := &OrderMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &OrderMockCreateOrderParams{input},
		expectationOrigins: OrderMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Order.CreateOrder return parameters for the expectation previously defined by the When method
func (e *OrderMockCreateOrderExpectation) Then(uid string, err error) *OrderMock {
	e.results = &OrderMockCreateOrderResults{uid, err}
	return e.mock
}

// Times sets number of times Order.CreateOrder should be invoked
func (mmCreateOrder *mOrderMockCreateOrder) Times(n uint64) *mOrderMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of OrderMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mOrderMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_repository.Order
func (mmCreateOrder *OrderMock) CreateOrder(input *model.Reply) (uid string, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(input)
	}

	mm_params := OrderMockCreateOrderParams{input}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uid, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderMockCreateOrderParams{input}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.input != nil && !minimock.Equal(*mm_want_ptrs.input, mm_got.input) {
				mmCreateOrder.t.Errorf("OrderMock.CreateOrder got unexpected parameter input, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originInput, *mm_want_ptrs.input, mm_got.input, minimock.Diff(*mm_want_ptrs.input, mm_got.input))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("OrderMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the OrderMock.CreateOrder")
		}
		return (*mm_results).uid, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(input)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to OrderMock.CreateOrder. %v", input)
	return
}

// CreateOrderAfterCounter returns a count of finished OrderMock.CreateOrder invocations
func (mmCreateOrder *OrderMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of OrderMock.CreateOrder invocations
func (mmCreateOrder *OrderMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mOrderMockCreateOrder) Calls() []*OrderMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*OrderMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *OrderMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mOrderMockGetOrderByUid struct {
	optional           bool
	mock               *OrderMock
	defaultExpectation *OrderMockGetOrderByUidExpectation
	expectations       []*OrderMockGetOrderByUidExpectation

	callArgs []*OrderMockGetOrderByUidParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderMockGetOrderByUidExpectation specifies expectation struct of the Order.GetOrderByUid
type OrderMockGetOrderByUidExpectation struct {
	mock               *OrderMock
	params             *OrderMockGetOrderByUidParams
	paramPtrs          *OrderMockGetOrderByUidParamPtrs
	expectationOrigins OrderMockGetOrderByUidExpectationOrigins
	results            *OrderMockGetOrderByUidResults
	returnOrigin       string
	Counter            uint64
}

// OrderMockGetOrderByUidParams contains parameters of the Order.GetOrderByUid
type OrderMockGetOrderByUidParams struct {
	uid string
}

// OrderMockGetOrderByUidParamPtrs contains pointers to parameters of the Order.GetOrderByUid
type OrderMockGetOrderByUidParamPtrs struct {
	uid *string
}

// OrderMockGetOrderByUidResults contains results of the Order.GetOrderByUid
type OrderMockGetOrderByUidResults struct {
	r1  model.Reply
	err error
}

// OrderMockGetOrderByUidOrigins contains origins of expectations of the Order.GetOrderByUid
type OrderMockGetOrderByUidExpectationOrigins struct {
	origin    string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderByUid *mOrderMockGetOrderByUid) Optional() *mOrderMockGetOrderByUid {
	mmGetOrderByUid.optional = true
	return mmGetOrderByUid
}

// Expect sets up expected params for Order.GetOrderByUid
func (mmGetOrderByUid *mOrderMockGetOrderByUid) Expect(uid string) *mOrderMockGetOrderByUid {
	if mmGetOrderByUid.mock.funcGetOrderByUid != nil {
		mmGetOrderByUid.mock.t.Fatalf("OrderMock.GetOrderByUid mock is already set by Set")
	}

	if mmGetOrderByUid.defaultExpectation == nil {
		mmGetOrderByUid.defaultExpectation = &OrderMockGetOrderByUidExpectation{}
	}

	if mmGetOrderByUid.defaultExpectation.paramPtrs != nil {
		mmGetOrderByUid.mock.t.Fatalf("OrderMock.GetOrderByUid mock is already set by ExpectParams functions")
	}

	mmGetOrderByUid.defaultExpectation.params = &OrderMockGetOrderByUidParams{uid}
	mmGetOrderByUid.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrderByUid.expectations {
		if minimock.Equal(e.params, mmGetOrderByUid.defaultExpectation.params) {
			mmGetOrderByUid.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByUid.defaultExpectation.params)
		}
	}

	return mmGetOrderByUid
}

// ExpectUidParam1 sets up expected param uid for Order.GetOrderByUid
func (mmGetOrderByUid *mOrderMockGetOrderByUid) ExpectUidParam1(uid string) *mOrderMockGetOrderByUid {
	if mmGetOrderByUid.mock.funcGetOrderByUid != nil {
		mmGetOrderByUid.mock.t.Fatalf("OrderMock.GetOrderByUid mock is already set by Set")
	}

	if mmGetOrderByUid.defaultExpectation == nil {
		mmGetOrderByUid.defaultExpectation = &OrderMockGetOrderByUidExpectation{}
	}

	if mmGetOrderByUid.defaultExpectation.params != nil {
		mmGetOrderByUid.mock.t.Fatalf("OrderMock.GetOrderByUid mock is already set by Expect")
	}

	if mmGetOrderByUid.defaultExpectation.paramPtrs == nil {
		mmGetOrderByUid.defaultExpectation.paramPtrs = &OrderMockGetOrderByUidParamPtrs{}
	}
	mmGetOrderByUid.defaultExpectation.paramPtrs.uid = &uid
	mmGetOrderByUid.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetOrderByUid
}

// Inspect accepts an inspector function that has same arguments as the Order.GetOrderByUid
func (mmGetOrderByUid *mOrderMockGetOrderByUid) Inspect(f func(uid string)) *mOrderMockGetOrderByUid {
	if mmGetOrderByUid.mock.inspectFuncGetOrderByUid != nil {
		mmGetOrderByUid.mock.t.Fatalf("Inspect function is already set for OrderMock.GetOrderByUid")
	}

	mmGetOrderByUid.mock.inspectFuncGetOrderByUid = f

	return mmGetOrderByUid
}

// Return sets up results that will be returned by Order.GetOrderByUid
func (mmGetOrderByUid *mOrderMockGetOrderByUid) Return(r1 model.Reply, err error) *OrderMock {
	if mmGetOrderByUid.mock.funcGetOrderByUid != nil {
		mmGetOrderByUid.mock.t.Fatalf("OrderMock.GetOrderByUid mock is already set by Set")
	}

	if mmGetOrderByUid.defaultExpectation == nil {
		mmGetOrderByUid.defaultExpectation = &OrderMockGetOrderByUidExpectation{mock: mmGetOrderByUid.mock}
	}
	mmGetOrderByUid.defaultExpectation.results = &OrderMockGetOrderByUidResults{r1, err}
	mmGetOrderByUid.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrderByUid.mock
}

// Set uses given function f to mock the Order.GetOrderByUid method
func (mmGetOrderByUid *mOrderMockGetOrderByUid) Set(f func(uid string) (r1 model.Reply, err error)) *OrderMock {
	if mmGetOrderByUid.defaultExpectation != nil {
		mmGetOrderByUid.mock.t.Fatalf("Default expectation is already set for the Order.GetOrderByUid method")
	}

	if len(mmGetOrderByUid.expectations) > 0 {
		mmGetOrderByUid.mock.t.Fatalf("Some expectations are already set for the Order.GetOrderByUid method")
	}

	mmGetOrderByUid.mock.funcGetOrderByUid = f
	mmGetOrderByUid.mock.funcGetOrderByUidOrigin = minimock.CallerInfo(1)
	return mmGetOrderByUid.mock
}

// When sets expectation for the Order.GetOrderByUid which will trigger the result defined by the following
// Then helper
func (mmGetOrderByUid *mOrderMockGetOrderByUid) When(uid string) *OrderMockGetOrderByUidExpectation {
	if mmGetOrderByUid.mock.funcGetOrderByUid != nil {
		mmGetOrderByUid.mock.t.Fatalf("OrderMock.GetOrderByUid mock is already set by Set")
	}

	expectation := &OrderMockGetOrderByUidExpectation{
		mock:               mmGetOrderByUid.mock,
		params:             &OrderMockGetOrderByUidParams{uid},
		expectationOrigins: OrderMockGetOrderByUidExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrderByUid.expectations = append(mmGetOrderByUid.expectations, expectation)
	return expectation
}

// Then sets up Order.GetOrderByUid return parameters for the expectation previously defined by the When method
func (e *OrderMockGetOrderByUidExpectation) Then(r1 model.Reply, err error) *OrderMock {
	e.results = &OrderMockGetOrderByUidResults{r1, err}
	return e.mock
}

// Times sets number of times Order.GetOrderByUid should be invoked
func (mmGetOrderByUid *mOrderMockGetOrderByUid) Times(n uint64) *mOrderMockGetOrderByUid {
	if n == 0 {
		mmGetOrderByUid.mock.t.Fatalf("Times of OrderMock.GetOrderByUid mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderByUid.expectedInvocations, n)
	mmGetOrderByUid.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrderByUid
}

func (mmGetOrderByUid *mOrderMockGetOrderByUid) invocationsDone() bool {
	if len(mmGetOrderByUid.expectations) == 0 && mmGetOrderByUid.defaultExpectation == nil && mmGetOrderByUid.mock.funcGetOrderByUid == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderByUid.mock.afterGetOrderByUidCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderByUid.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderByUid implements mm_repository.Order
func (mmGetOrderByUid *OrderMock) GetOrderByUid(uid string) (r1 model.Reply, err error) {
	mm_atomic.AddUint64(&mmGetOrderByUid.beforeGetOrderByUidCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByUid.afterGetOrderByUidCounter, 1)

	mmGetOrderByUid.t.Helper()

	if mmGetOrderByUid.inspectFuncGetOrderByUid != nil {
		mmGetOrderByUid.inspectFuncGetOrderByUid(uid)
	}

	mm_params := OrderMockGetOrderByUidParams{uid}

	// Record call args
	mmGetOrderByUid.GetOrderByUidMock.mutex.Lock()
	mmGetOrderByUid.GetOrderByUidMock.callArgs = append(mmGetOrderByUid.GetOrderByUidMock.callArgs, &mm_params)
	mmGetOrderByUid.GetOrderByUidMock.mutex.Unlock()

	for _, e := range mmGetOrderByUid.GetOrderByUidMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetOrderByUid.GetOrderByUidMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByUid.GetOrderByUidMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByUid.GetOrderByUidMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderByUid.GetOrderByUidMock.defaultExpectation.paramPtrs

		mm_got := OrderMockGetOrderByUidParams{uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetOrderByUid.t.Errorf("OrderMock.GetOrderByUid got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrderByUid.GetOrderByUidMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByUid.t.Errorf("OrderMock.GetOrderByUid got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrderByUid.GetOrderByUidMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByUid.GetOrderByUidMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByUid.t.Fatal("No results are set for the OrderMock.GetOrderByUid")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetOrderByUid.funcGetOrderByUid != nil {
		return mmGetOrderByUid.funcGetOrderByUid(uid)
	}
	mmGetOrderByUid.t.Fatalf("Unexpected call to OrderMock.GetOrderByUid. %v", uid)
	return
}

// GetOrderByUidAfterCounter returns a count of finished OrderMock.GetOrderByUid invocations
func (mmGetOrderByUid *OrderMock) GetOrderByUidAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByUid.afterGetOrderByUidCounter)
}

// GetOrderByUidBeforeCounter returns a count of OrderMock.GetOrderByUid invocations
func (mmGetOrderByUid *OrderMock) GetOrderByUidBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByUid.beforeGetOrderByUidCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.GetOrderByUid.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByUid *mOrderMockGetOrderByUid) Calls() []*OrderMockGetOrderByUidParams {
	mmGetOrderByUid.mutex.RLock()

	argCopy := make([]*OrderMockGetOrderByUidParams, len(mmGetOrderByUid.callArgs))
	copy(argCopy, mmGetOrderByUid.callArgs)

	mmGetOrderByUid.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByUidDone returns true if the count of the GetOrderByUid invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockGetOrderByUidDone() bool {
	if m.GetOrderByUidMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderByUidMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderByUidMock.invocationsDone()
}

// MinimockGetOrderByUidInspect logs each unmet expectation
func (m *OrderMock) MinimockGetOrderByUidInspect() {
	for _, e := range m.GetOrderByUidMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.GetOrderByUid at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderByUidCounter := mm_atomic.LoadUint64(&m.afterGetOrderByUidCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByUidMock.defaultExpectation != nil && afterGetOrderByUidCounter < 1 {
		if m.GetOrderByUidMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderMock.GetOrderByUid at\n%s", m.GetOrderByUidMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderMock.GetOrderByUid at\n%s with params: %#v", m.GetOrderByUidMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderByUidMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByUid != nil && afterGetOrderByUidCounter < 1 {
		m.t.Errorf("Expected call to OrderMock.GetOrderByUid at\n%s", m.funcGetOrderByUidOrigin)
	}

	if !m.GetOrderByUidMock.invocationsDone() && afterGetOrderByUidCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderMock.GetOrderByUid at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderByUidMock.expectedInvocations), m.GetOrderByUidMock.expectedInvocationsOrigin, afterGetOrderByUidCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckOrderExistsInspect()

			m.MinimockCreateOrderInspect()

			m.MinimockGetOrderByUidInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckOrderExistsDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetOrderByUidDone()
}
