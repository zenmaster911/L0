// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/zenmaster911/L0/pkg/service.Customer -o customer_mock.go -n CustomerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/zenmaster911/L0/pkg/model"
)

// CustomerMock implements mm_service.Customer
type CustomerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCustomerByPhone          func(phone string) (c1 model.Customer, err error)
	funcGetCustomerByPhoneOrigin    string
	inspectFuncGetCustomerByPhone   func(phone string)
	afterGetCustomerByPhoneCounter  uint64
	beforeGetCustomerByPhoneCounter uint64
	GetCustomerByPhoneMock          mCustomerMockGetCustomerByPhone
}

// NewCustomerMock returns a mock for mm_service.Customer
func NewCustomerMock(t minimock.Tester) *CustomerMock {
	m := &CustomerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCustomerByPhoneMock = mCustomerMockGetCustomerByPhone{mock: m}
	m.GetCustomerByPhoneMock.callArgs = []*CustomerMockGetCustomerByPhoneParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCustomerMockGetCustomerByPhone struct {
	optional           bool
	mock               *CustomerMock
	defaultExpectation *CustomerMockGetCustomerByPhoneExpectation
	expectations       []*CustomerMockGetCustomerByPhoneExpectation

	callArgs []*CustomerMockGetCustomerByPhoneParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CustomerMockGetCustomerByPhoneExpectation specifies expectation struct of the Customer.GetCustomerByPhone
type CustomerMockGetCustomerByPhoneExpectation struct {
	mock               *CustomerMock
	params             *CustomerMockGetCustomerByPhoneParams
	paramPtrs          *CustomerMockGetCustomerByPhoneParamPtrs
	expectationOrigins CustomerMockGetCustomerByPhoneExpectationOrigins
	results            *CustomerMockGetCustomerByPhoneResults
	returnOrigin       string
	Counter            uint64
}

// CustomerMockGetCustomerByPhoneParams contains parameters of the Customer.GetCustomerByPhone
type CustomerMockGetCustomerByPhoneParams struct {
	phone string
}

// CustomerMockGetCustomerByPhoneParamPtrs contains pointers to parameters of the Customer.GetCustomerByPhone
type CustomerMockGetCustomerByPhoneParamPtrs struct {
	phone *string
}

// CustomerMockGetCustomerByPhoneResults contains results of the Customer.GetCustomerByPhone
type CustomerMockGetCustomerByPhoneResults struct {
	c1  model.Customer
	err error
}

// CustomerMockGetCustomerByPhoneOrigins contains origins of expectations of the Customer.GetCustomerByPhone
type CustomerMockGetCustomerByPhoneExpectationOrigins struct {
	origin      string
	originPhone string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) Optional() *mCustomerMockGetCustomerByPhone {
	mmGetCustomerByPhone.optional = true
	return mmGetCustomerByPhone
}

// Expect sets up expected params for Customer.GetCustomerByPhone
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) Expect(phone string) *mCustomerMockGetCustomerByPhone {
	if mmGetCustomerByPhone.mock.funcGetCustomerByPhone != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("CustomerMock.GetCustomerByPhone mock is already set by Set")
	}

	if mmGetCustomerByPhone.defaultExpectation == nil {
		mmGetCustomerByPhone.defaultExpectation = &CustomerMockGetCustomerByPhoneExpectation{}
	}

	if mmGetCustomerByPhone.defaultExpectation.paramPtrs != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("CustomerMock.GetCustomerByPhone mock is already set by ExpectParams functions")
	}

	mmGetCustomerByPhone.defaultExpectation.params = &CustomerMockGetCustomerByPhoneParams{phone}
	mmGetCustomerByPhone.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCustomerByPhone.expectations {
		if minimock.Equal(e.params, mmGetCustomerByPhone.defaultExpectation.params) {
			mmGetCustomerByPhone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCustomerByPhone.defaultExpectation.params)
		}
	}

	return mmGetCustomerByPhone
}

// ExpectPhoneParam1 sets up expected param phone for Customer.GetCustomerByPhone
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) ExpectPhoneParam1(phone string) *mCustomerMockGetCustomerByPhone {
	if mmGetCustomerByPhone.mock.funcGetCustomerByPhone != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("CustomerMock.GetCustomerByPhone mock is already set by Set")
	}

	if mmGetCustomerByPhone.defaultExpectation == nil {
		mmGetCustomerByPhone.defaultExpectation = &CustomerMockGetCustomerByPhoneExpectation{}
	}

	if mmGetCustomerByPhone.defaultExpectation.params != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("CustomerMock.GetCustomerByPhone mock is already set by Expect")
	}

	if mmGetCustomerByPhone.defaultExpectation.paramPtrs == nil {
		mmGetCustomerByPhone.defaultExpectation.paramPtrs = &CustomerMockGetCustomerByPhoneParamPtrs{}
	}
	mmGetCustomerByPhone.defaultExpectation.paramPtrs.phone = &phone
	mmGetCustomerByPhone.defaultExpectation.expectationOrigins.originPhone = minimock.CallerInfo(1)

	return mmGetCustomerByPhone
}

// Inspect accepts an inspector function that has same arguments as the Customer.GetCustomerByPhone
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) Inspect(f func(phone string)) *mCustomerMockGetCustomerByPhone {
	if mmGetCustomerByPhone.mock.inspectFuncGetCustomerByPhone != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("Inspect function is already set for CustomerMock.GetCustomerByPhone")
	}

	mmGetCustomerByPhone.mock.inspectFuncGetCustomerByPhone = f

	return mmGetCustomerByPhone
}

// Return sets up results that will be returned by Customer.GetCustomerByPhone
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) Return(c1 model.Customer, err error) *CustomerMock {
	if mmGetCustomerByPhone.mock.funcGetCustomerByPhone != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("CustomerMock.GetCustomerByPhone mock is already set by Set")
	}

	if mmGetCustomerByPhone.defaultExpectation == nil {
		mmGetCustomerByPhone.defaultExpectation = &CustomerMockGetCustomerByPhoneExpectation{mock: mmGetCustomerByPhone.mock}
	}
	mmGetCustomerByPhone.defaultExpectation.results = &CustomerMockGetCustomerByPhoneResults{c1, err}
	mmGetCustomerByPhone.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCustomerByPhone.mock
}

// Set uses given function f to mock the Customer.GetCustomerByPhone method
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) Set(f func(phone string) (c1 model.Customer, err error)) *CustomerMock {
	if mmGetCustomerByPhone.defaultExpectation != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("Default expectation is already set for the Customer.GetCustomerByPhone method")
	}

	if len(mmGetCustomerByPhone.expectations) > 0 {
		mmGetCustomerByPhone.mock.t.Fatalf("Some expectations are already set for the Customer.GetCustomerByPhone method")
	}

	mmGetCustomerByPhone.mock.funcGetCustomerByPhone = f
	mmGetCustomerByPhone.mock.funcGetCustomerByPhoneOrigin = minimock.CallerInfo(1)
	return mmGetCustomerByPhone.mock
}

// When sets expectation for the Customer.GetCustomerByPhone which will trigger the result defined by the following
// Then helper
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) When(phone string) *CustomerMockGetCustomerByPhoneExpectation {
	if mmGetCustomerByPhone.mock.funcGetCustomerByPhone != nil {
		mmGetCustomerByPhone.mock.t.Fatalf("CustomerMock.GetCustomerByPhone mock is already set by Set")
	}

	expectation := &CustomerMockGetCustomerByPhoneExpectation{
		mock:               mmGetCustomerByPhone.mock,
		params:             &CustomerMockGetCustomerByPhoneParams{phone},
		expectationOrigins: CustomerMockGetCustomerByPhoneExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCustomerByPhone.expectations = append(mmGetCustomerByPhone.expectations, expectation)
	return expectation
}

// Then sets up Customer.GetCustomerByPhone return parameters for the expectation previously defined by the When method
func (e *CustomerMockGetCustomerByPhoneExpectation) Then(c1 model.Customer, err error) *CustomerMock {
	e.results = &CustomerMockGetCustomerByPhoneResults{c1, err}
	return e.mock
}

// Times sets number of times Customer.GetCustomerByPhone should be invoked
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) Times(n uint64) *mCustomerMockGetCustomerByPhone {
	if n == 0 {
		mmGetCustomerByPhone.mock.t.Fatalf("Times of CustomerMock.GetCustomerByPhone mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCustomerByPhone.expectedInvocations, n)
	mmGetCustomerByPhone.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCustomerByPhone
}

func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) invocationsDone() bool {
	if len(mmGetCustomerByPhone.expectations) == 0 && mmGetCustomerByPhone.defaultExpectation == nil && mmGetCustomerByPhone.mock.funcGetCustomerByPhone == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCustomerByPhone.mock.afterGetCustomerByPhoneCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCustomerByPhone.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCustomerByPhone implements mm_service.Customer
func (mmGetCustomerByPhone *CustomerMock) GetCustomerByPhone(phone string) (c1 model.Customer, err error) {
	mm_atomic.AddUint64(&mmGetCustomerByPhone.beforeGetCustomerByPhoneCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCustomerByPhone.afterGetCustomerByPhoneCounter, 1)

	mmGetCustomerByPhone.t.Helper()

	if mmGetCustomerByPhone.inspectFuncGetCustomerByPhone != nil {
		mmGetCustomerByPhone.inspectFuncGetCustomerByPhone(phone)
	}

	mm_params := CustomerMockGetCustomerByPhoneParams{phone}

	// Record call args
	mmGetCustomerByPhone.GetCustomerByPhoneMock.mutex.Lock()
	mmGetCustomerByPhone.GetCustomerByPhoneMock.callArgs = append(mmGetCustomerByPhone.GetCustomerByPhoneMock.callArgs, &mm_params)
	mmGetCustomerByPhone.GetCustomerByPhoneMock.mutex.Unlock()

	for _, e := range mmGetCustomerByPhone.GetCustomerByPhoneMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmGetCustomerByPhone.GetCustomerByPhoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCustomerByPhone.GetCustomerByPhoneMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCustomerByPhone.GetCustomerByPhoneMock.defaultExpectation.params
		mm_want_ptrs := mmGetCustomerByPhone.GetCustomerByPhoneMock.defaultExpectation.paramPtrs

		mm_got := CustomerMockGetCustomerByPhoneParams{phone}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.phone != nil && !minimock.Equal(*mm_want_ptrs.phone, mm_got.phone) {
				mmGetCustomerByPhone.t.Errorf("CustomerMock.GetCustomerByPhone got unexpected parameter phone, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCustomerByPhone.GetCustomerByPhoneMock.defaultExpectation.expectationOrigins.originPhone, *mm_want_ptrs.phone, mm_got.phone, minimock.Diff(*mm_want_ptrs.phone, mm_got.phone))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCustomerByPhone.t.Errorf("CustomerMock.GetCustomerByPhone got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCustomerByPhone.GetCustomerByPhoneMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCustomerByPhone.GetCustomerByPhoneMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCustomerByPhone.t.Fatal("No results are set for the CustomerMock.GetCustomerByPhone")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmGetCustomerByPhone.funcGetCustomerByPhone != nil {
		return mmGetCustomerByPhone.funcGetCustomerByPhone(phone)
	}
	mmGetCustomerByPhone.t.Fatalf("Unexpected call to CustomerMock.GetCustomerByPhone. %v", phone)
	return
}

// GetCustomerByPhoneAfterCounter returns a count of finished CustomerMock.GetCustomerByPhone invocations
func (mmGetCustomerByPhone *CustomerMock) GetCustomerByPhoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCustomerByPhone.afterGetCustomerByPhoneCounter)
}

// GetCustomerByPhoneBeforeCounter returns a count of CustomerMock.GetCustomerByPhone invocations
func (mmGetCustomerByPhone *CustomerMock) GetCustomerByPhoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCustomerByPhone.beforeGetCustomerByPhoneCounter)
}

// Calls returns a list of arguments used in each call to CustomerMock.GetCustomerByPhone.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCustomerByPhone *mCustomerMockGetCustomerByPhone) Calls() []*CustomerMockGetCustomerByPhoneParams {
	mmGetCustomerByPhone.mutex.RLock()

	argCopy := make([]*CustomerMockGetCustomerByPhoneParams, len(mmGetCustomerByPhone.callArgs))
	copy(argCopy, mmGetCustomerByPhone.callArgs)

	mmGetCustomerByPhone.mutex.RUnlock()

	return argCopy
}

// MinimockGetCustomerByPhoneDone returns true if the count of the GetCustomerByPhone invocations corresponds
// the number of defined expectations
func (m *CustomerMock) MinimockGetCustomerByPhoneDone() bool {
	if m.GetCustomerByPhoneMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCustomerByPhoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCustomerByPhoneMock.invocationsDone()
}

// MinimockGetCustomerByPhoneInspect logs each unmet expectation
func (m *CustomerMock) MinimockGetCustomerByPhoneInspect() {
	for _, e := range m.GetCustomerByPhoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerMock.GetCustomerByPhone at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCustomerByPhoneCounter := mm_atomic.LoadUint64(&m.afterGetCustomerByPhoneCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCustomerByPhoneMock.defaultExpectation != nil && afterGetCustomerByPhoneCounter < 1 {
		if m.GetCustomerByPhoneMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CustomerMock.GetCustomerByPhone at\n%s", m.GetCustomerByPhoneMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CustomerMock.GetCustomerByPhone at\n%s with params: %#v", m.GetCustomerByPhoneMock.defaultExpectation.expectationOrigins.origin, *m.GetCustomerByPhoneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCustomerByPhone != nil && afterGetCustomerByPhoneCounter < 1 {
		m.t.Errorf("Expected call to CustomerMock.GetCustomerByPhone at\n%s", m.funcGetCustomerByPhoneOrigin)
	}

	if !m.GetCustomerByPhoneMock.invocationsDone() && afterGetCustomerByPhoneCounter > 0 {
		m.t.Errorf("Expected %d calls to CustomerMock.GetCustomerByPhone at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCustomerByPhoneMock.expectedInvocations), m.GetCustomerByPhoneMock.expectedInvocationsOrigin, afterGetCustomerByPhoneCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CustomerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCustomerByPhoneInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CustomerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CustomerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCustomerByPhoneDone()
}
