// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package cache_mocks

//go:generate minimock -i github.com/zenmaster911/L0/pkg/cache.RedisCacheInterface -o redis_cache_interface_mock.go -n RedisCacheInterfaceMock -p cache_mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/zenmaster911/L0/pkg/model"
)

// RedisCacheInterfaceMock implements mm_cache.RedisCacheInterface
type RedisCacheInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddToCache          func(ctx context.Context, order model.Reply) (err error)
	funcAddToCacheOrigin    string
	inspectFuncAddToCache   func(ctx context.Context, order model.Reply)
	afterAddToCacheCounter  uint64
	beforeAddToCacheCounter uint64
	AddToCacheMock          mRedisCacheInterfaceMockAddToCache

	funcCacheLoad          func(ctx context.Context, limit int) (err error)
	funcCacheLoadOrigin    string
	inspectFuncCacheLoad   func(ctx context.Context, limit int)
	afterCacheLoadCounter  uint64
	beforeCacheLoadCounter uint64
	CacheLoadMock          mRedisCacheInterfaceMockCacheLoad

	funcReadFromCache          func(ctx context.Context, uid string) (reply model.Reply, err error)
	funcReadFromCacheOrigin    string
	inspectFuncReadFromCache   func(ctx context.Context, uid string)
	afterReadFromCacheCounter  uint64
	beforeReadFromCacheCounter uint64
	ReadFromCacheMock          mRedisCacheInterfaceMockReadFromCache
}

// NewRedisCacheInterfaceMock returns a mock for mm_cache.RedisCacheInterface
func NewRedisCacheInterfaceMock(t minimock.Tester) *RedisCacheInterfaceMock {
	m := &RedisCacheInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCacheMock = mRedisCacheInterfaceMockAddToCache{mock: m}
	m.AddToCacheMock.callArgs = []*RedisCacheInterfaceMockAddToCacheParams{}

	m.CacheLoadMock = mRedisCacheInterfaceMockCacheLoad{mock: m}
	m.CacheLoadMock.callArgs = []*RedisCacheInterfaceMockCacheLoadParams{}

	m.ReadFromCacheMock = mRedisCacheInterfaceMockReadFromCache{mock: m}
	m.ReadFromCacheMock.callArgs = []*RedisCacheInterfaceMockReadFromCacheParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRedisCacheInterfaceMockAddToCache struct {
	optional           bool
	mock               *RedisCacheInterfaceMock
	defaultExpectation *RedisCacheInterfaceMockAddToCacheExpectation
	expectations       []*RedisCacheInterfaceMockAddToCacheExpectation

	callArgs []*RedisCacheInterfaceMockAddToCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCacheInterfaceMockAddToCacheExpectation specifies expectation struct of the RedisCacheInterface.AddToCache
type RedisCacheInterfaceMockAddToCacheExpectation struct {
	mock               *RedisCacheInterfaceMock
	params             *RedisCacheInterfaceMockAddToCacheParams
	paramPtrs          *RedisCacheInterfaceMockAddToCacheParamPtrs
	expectationOrigins RedisCacheInterfaceMockAddToCacheExpectationOrigins
	results            *RedisCacheInterfaceMockAddToCacheResults
	returnOrigin       string
	Counter            uint64
}

// RedisCacheInterfaceMockAddToCacheParams contains parameters of the RedisCacheInterface.AddToCache
type RedisCacheInterfaceMockAddToCacheParams struct {
	ctx   context.Context
	order model.Reply
}

// RedisCacheInterfaceMockAddToCacheParamPtrs contains pointers to parameters of the RedisCacheInterface.AddToCache
type RedisCacheInterfaceMockAddToCacheParamPtrs struct {
	ctx   *context.Context
	order *model.Reply
}

// RedisCacheInterfaceMockAddToCacheResults contains results of the RedisCacheInterface.AddToCache
type RedisCacheInterfaceMockAddToCacheResults struct {
	err error
}

// RedisCacheInterfaceMockAddToCacheOrigins contains origins of expectations of the RedisCacheInterface.AddToCache
type RedisCacheInterfaceMockAddToCacheExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) Optional() *mRedisCacheInterfaceMockAddToCache {
	mmAddToCache.optional = true
	return mmAddToCache
}

// Expect sets up expected params for RedisCacheInterface.AddToCache
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) Expect(ctx context.Context, order model.Reply) *mRedisCacheInterfaceMockAddToCache {
	if mmAddToCache.mock.funcAddToCache != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by Set")
	}

	if mmAddToCache.defaultExpectation == nil {
		mmAddToCache.defaultExpectation = &RedisCacheInterfaceMockAddToCacheExpectation{}
	}

	if mmAddToCache.defaultExpectation.paramPtrs != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by ExpectParams functions")
	}

	mmAddToCache.defaultExpectation.params = &RedisCacheInterfaceMockAddToCacheParams{ctx, order}
	mmAddToCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddToCache.expectations {
		if minimock.Equal(e.params, mmAddToCache.defaultExpectation.params) {
			mmAddToCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCache.defaultExpectation.params)
		}
	}

	return mmAddToCache
}

// ExpectCtxParam1 sets up expected param ctx for RedisCacheInterface.AddToCache
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) ExpectCtxParam1(ctx context.Context) *mRedisCacheInterfaceMockAddToCache {
	if mmAddToCache.mock.funcAddToCache != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by Set")
	}

	if mmAddToCache.defaultExpectation == nil {
		mmAddToCache.defaultExpectation = &RedisCacheInterfaceMockAddToCacheExpectation{}
	}

	if mmAddToCache.defaultExpectation.params != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by Expect")
	}

	if mmAddToCache.defaultExpectation.paramPtrs == nil {
		mmAddToCache.defaultExpectation.paramPtrs = &RedisCacheInterfaceMockAddToCacheParamPtrs{}
	}
	mmAddToCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddToCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddToCache
}

// ExpectOrderParam2 sets up expected param order for RedisCacheInterface.AddToCache
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) ExpectOrderParam2(order model.Reply) *mRedisCacheInterfaceMockAddToCache {
	if mmAddToCache.mock.funcAddToCache != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by Set")
	}

	if mmAddToCache.defaultExpectation == nil {
		mmAddToCache.defaultExpectation = &RedisCacheInterfaceMockAddToCacheExpectation{}
	}

	if mmAddToCache.defaultExpectation.params != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by Expect")
	}

	if mmAddToCache.defaultExpectation.paramPtrs == nil {
		mmAddToCache.defaultExpectation.paramPtrs = &RedisCacheInterfaceMockAddToCacheParamPtrs{}
	}
	mmAddToCache.defaultExpectation.paramPtrs.order = &order
	mmAddToCache.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmAddToCache
}

// Inspect accepts an inspector function that has same arguments as the RedisCacheInterface.AddToCache
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) Inspect(f func(ctx context.Context, order model.Reply)) *mRedisCacheInterfaceMockAddToCache {
	if mmAddToCache.mock.inspectFuncAddToCache != nil {
		mmAddToCache.mock.t.Fatalf("Inspect function is already set for RedisCacheInterfaceMock.AddToCache")
	}

	mmAddToCache.mock.inspectFuncAddToCache = f

	return mmAddToCache
}

// Return sets up results that will be returned by RedisCacheInterface.AddToCache
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) Return(err error) *RedisCacheInterfaceMock {
	if mmAddToCache.mock.funcAddToCache != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by Set")
	}

	if mmAddToCache.defaultExpectation == nil {
		mmAddToCache.defaultExpectation = &RedisCacheInterfaceMockAddToCacheExpectation{mock: mmAddToCache.mock}
	}
	mmAddToCache.defaultExpectation.results = &RedisCacheInterfaceMockAddToCacheResults{err}
	mmAddToCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddToCache.mock
}

// Set uses given function f to mock the RedisCacheInterface.AddToCache method
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) Set(f func(ctx context.Context, order model.Reply) (err error)) *RedisCacheInterfaceMock {
	if mmAddToCache.defaultExpectation != nil {
		mmAddToCache.mock.t.Fatalf("Default expectation is already set for the RedisCacheInterface.AddToCache method")
	}

	if len(mmAddToCache.expectations) > 0 {
		mmAddToCache.mock.t.Fatalf("Some expectations are already set for the RedisCacheInterface.AddToCache method")
	}

	mmAddToCache.mock.funcAddToCache = f
	mmAddToCache.mock.funcAddToCacheOrigin = minimock.CallerInfo(1)
	return mmAddToCache.mock
}

// When sets expectation for the RedisCacheInterface.AddToCache which will trigger the result defined by the following
// Then helper
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) When(ctx context.Context, order model.Reply) *RedisCacheInterfaceMockAddToCacheExpectation {
	if mmAddToCache.mock.funcAddToCache != nil {
		mmAddToCache.mock.t.Fatalf("RedisCacheInterfaceMock.AddToCache mock is already set by Set")
	}

	expectation := &RedisCacheInterfaceMockAddToCacheExpectation{
		mock:               mmAddToCache.mock,
		params:             &RedisCacheInterfaceMockAddToCacheParams{ctx, order},
		expectationOrigins: RedisCacheInterfaceMockAddToCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddToCache.expectations = append(mmAddToCache.expectations, expectation)
	return expectation
}

// Then sets up RedisCacheInterface.AddToCache return parameters for the expectation previously defined by the When method
func (e *RedisCacheInterfaceMockAddToCacheExpectation) Then(err error) *RedisCacheInterfaceMock {
	e.results = &RedisCacheInterfaceMockAddToCacheResults{err}
	return e.mock
}

// Times sets number of times RedisCacheInterface.AddToCache should be invoked
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) Times(n uint64) *mRedisCacheInterfaceMockAddToCache {
	if n == 0 {
		mmAddToCache.mock.t.Fatalf("Times of RedisCacheInterfaceMock.AddToCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddToCache.expectedInvocations, n)
	mmAddToCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddToCache
}

func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) invocationsDone() bool {
	if len(mmAddToCache.expectations) == 0 && mmAddToCache.defaultExpectation == nil && mmAddToCache.mock.funcAddToCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddToCache.mock.afterAddToCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddToCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddToCache implements mm_cache.RedisCacheInterface
func (mmAddToCache *RedisCacheInterfaceMock) AddToCache(ctx context.Context, order model.Reply) (err error) {
	mm_atomic.AddUint64(&mmAddToCache.beforeAddToCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCache.afterAddToCacheCounter, 1)

	mmAddToCache.t.Helper()

	if mmAddToCache.inspectFuncAddToCache != nil {
		mmAddToCache.inspectFuncAddToCache(ctx, order)
	}

	mm_params := RedisCacheInterfaceMockAddToCacheParams{ctx, order}

	// Record call args
	mmAddToCache.AddToCacheMock.mutex.Lock()
	mmAddToCache.AddToCacheMock.callArgs = append(mmAddToCache.AddToCacheMock.callArgs, &mm_params)
	mmAddToCache.AddToCacheMock.mutex.Unlock()

	for _, e := range mmAddToCache.AddToCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCache.AddToCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCache.AddToCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCache.AddToCacheMock.defaultExpectation.params
		mm_want_ptrs := mmAddToCache.AddToCacheMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheInterfaceMockAddToCacheParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddToCache.t.Errorf("RedisCacheInterfaceMock.AddToCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToCache.AddToCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmAddToCache.t.Errorf("RedisCacheInterfaceMock.AddToCache got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToCache.AddToCacheMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCache.t.Errorf("RedisCacheInterfaceMock.AddToCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddToCache.AddToCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCache.AddToCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCache.t.Fatal("No results are set for the RedisCacheInterfaceMock.AddToCache")
		}
		return (*mm_results).err
	}
	if mmAddToCache.funcAddToCache != nil {
		return mmAddToCache.funcAddToCache(ctx, order)
	}
	mmAddToCache.t.Fatalf("Unexpected call to RedisCacheInterfaceMock.AddToCache. %v %v", ctx, order)
	return
}

// AddToCacheAfterCounter returns a count of finished RedisCacheInterfaceMock.AddToCache invocations
func (mmAddToCache *RedisCacheInterfaceMock) AddToCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCache.afterAddToCacheCounter)
}

// AddToCacheBeforeCounter returns a count of RedisCacheInterfaceMock.AddToCache invocations
func (mmAddToCache *RedisCacheInterfaceMock) AddToCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCache.beforeAddToCacheCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheInterfaceMock.AddToCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCache *mRedisCacheInterfaceMockAddToCache) Calls() []*RedisCacheInterfaceMockAddToCacheParams {
	mmAddToCache.mutex.RLock()

	argCopy := make([]*RedisCacheInterfaceMockAddToCacheParams, len(mmAddToCache.callArgs))
	copy(argCopy, mmAddToCache.callArgs)

	mmAddToCache.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCacheDone returns true if the count of the AddToCache invocations corresponds
// the number of defined expectations
func (m *RedisCacheInterfaceMock) MinimockAddToCacheDone() bool {
	if m.AddToCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddToCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddToCacheMock.invocationsDone()
}

// MinimockAddToCacheInspect logs each unmet expectation
func (m *RedisCacheInterfaceMock) MinimockAddToCacheInspect() {
	for _, e := range m.AddToCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.AddToCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddToCacheCounter := mm_atomic.LoadUint64(&m.afterAddToCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCacheMock.defaultExpectation != nil && afterAddToCacheCounter < 1 {
		if m.AddToCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.AddToCache at\n%s", m.AddToCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.AddToCache at\n%s with params: %#v", m.AddToCacheMock.defaultExpectation.expectationOrigins.origin, *m.AddToCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCache != nil && afterAddToCacheCounter < 1 {
		m.t.Errorf("Expected call to RedisCacheInterfaceMock.AddToCache at\n%s", m.funcAddToCacheOrigin)
	}

	if !m.AddToCacheMock.invocationsDone() && afterAddToCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheInterfaceMock.AddToCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddToCacheMock.expectedInvocations), m.AddToCacheMock.expectedInvocationsOrigin, afterAddToCacheCounter)
	}
}

type mRedisCacheInterfaceMockCacheLoad struct {
	optional           bool
	mock               *RedisCacheInterfaceMock
	defaultExpectation *RedisCacheInterfaceMockCacheLoadExpectation
	expectations       []*RedisCacheInterfaceMockCacheLoadExpectation

	callArgs []*RedisCacheInterfaceMockCacheLoadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCacheInterfaceMockCacheLoadExpectation specifies expectation struct of the RedisCacheInterface.CacheLoad
type RedisCacheInterfaceMockCacheLoadExpectation struct {
	mock               *RedisCacheInterfaceMock
	params             *RedisCacheInterfaceMockCacheLoadParams
	paramPtrs          *RedisCacheInterfaceMockCacheLoadParamPtrs
	expectationOrigins RedisCacheInterfaceMockCacheLoadExpectationOrigins
	results            *RedisCacheInterfaceMockCacheLoadResults
	returnOrigin       string
	Counter            uint64
}

// RedisCacheInterfaceMockCacheLoadParams contains parameters of the RedisCacheInterface.CacheLoad
type RedisCacheInterfaceMockCacheLoadParams struct {
	ctx   context.Context
	limit int
}

// RedisCacheInterfaceMockCacheLoadParamPtrs contains pointers to parameters of the RedisCacheInterface.CacheLoad
type RedisCacheInterfaceMockCacheLoadParamPtrs struct {
	ctx   *context.Context
	limit *int
}

// RedisCacheInterfaceMockCacheLoadResults contains results of the RedisCacheInterface.CacheLoad
type RedisCacheInterfaceMockCacheLoadResults struct {
	err error
}

// RedisCacheInterfaceMockCacheLoadOrigins contains origins of expectations of the RedisCacheInterface.CacheLoad
type RedisCacheInterfaceMockCacheLoadExpectationOrigins struct {
	origin      string
	originCtx   string
	originLimit string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) Optional() *mRedisCacheInterfaceMockCacheLoad {
	mmCacheLoad.optional = true
	return mmCacheLoad
}

// Expect sets up expected params for RedisCacheInterface.CacheLoad
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) Expect(ctx context.Context, limit int) *mRedisCacheInterfaceMockCacheLoad {
	if mmCacheLoad.mock.funcCacheLoad != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by Set")
	}

	if mmCacheLoad.defaultExpectation == nil {
		mmCacheLoad.defaultExpectation = &RedisCacheInterfaceMockCacheLoadExpectation{}
	}

	if mmCacheLoad.defaultExpectation.paramPtrs != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by ExpectParams functions")
	}

	mmCacheLoad.defaultExpectation.params = &RedisCacheInterfaceMockCacheLoadParams{ctx, limit}
	mmCacheLoad.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCacheLoad.expectations {
		if minimock.Equal(e.params, mmCacheLoad.defaultExpectation.params) {
			mmCacheLoad.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCacheLoad.defaultExpectation.params)
		}
	}

	return mmCacheLoad
}

// ExpectCtxParam1 sets up expected param ctx for RedisCacheInterface.CacheLoad
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) ExpectCtxParam1(ctx context.Context) *mRedisCacheInterfaceMockCacheLoad {
	if mmCacheLoad.mock.funcCacheLoad != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by Set")
	}

	if mmCacheLoad.defaultExpectation == nil {
		mmCacheLoad.defaultExpectation = &RedisCacheInterfaceMockCacheLoadExpectation{}
	}

	if mmCacheLoad.defaultExpectation.params != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by Expect")
	}

	if mmCacheLoad.defaultExpectation.paramPtrs == nil {
		mmCacheLoad.defaultExpectation.paramPtrs = &RedisCacheInterfaceMockCacheLoadParamPtrs{}
	}
	mmCacheLoad.defaultExpectation.paramPtrs.ctx = &ctx
	mmCacheLoad.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCacheLoad
}

// ExpectLimitParam2 sets up expected param limit for RedisCacheInterface.CacheLoad
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) ExpectLimitParam2(limit int) *mRedisCacheInterfaceMockCacheLoad {
	if mmCacheLoad.mock.funcCacheLoad != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by Set")
	}

	if mmCacheLoad.defaultExpectation == nil {
		mmCacheLoad.defaultExpectation = &RedisCacheInterfaceMockCacheLoadExpectation{}
	}

	if mmCacheLoad.defaultExpectation.params != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by Expect")
	}

	if mmCacheLoad.defaultExpectation.paramPtrs == nil {
		mmCacheLoad.defaultExpectation.paramPtrs = &RedisCacheInterfaceMockCacheLoadParamPtrs{}
	}
	mmCacheLoad.defaultExpectation.paramPtrs.limit = &limit
	mmCacheLoad.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmCacheLoad
}

// Inspect accepts an inspector function that has same arguments as the RedisCacheInterface.CacheLoad
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) Inspect(f func(ctx context.Context, limit int)) *mRedisCacheInterfaceMockCacheLoad {
	if mmCacheLoad.mock.inspectFuncCacheLoad != nil {
		mmCacheLoad.mock.t.Fatalf("Inspect function is already set for RedisCacheInterfaceMock.CacheLoad")
	}

	mmCacheLoad.mock.inspectFuncCacheLoad = f

	return mmCacheLoad
}

// Return sets up results that will be returned by RedisCacheInterface.CacheLoad
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) Return(err error) *RedisCacheInterfaceMock {
	if mmCacheLoad.mock.funcCacheLoad != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by Set")
	}

	if mmCacheLoad.defaultExpectation == nil {
		mmCacheLoad.defaultExpectation = &RedisCacheInterfaceMockCacheLoadExpectation{mock: mmCacheLoad.mock}
	}
	mmCacheLoad.defaultExpectation.results = &RedisCacheInterfaceMockCacheLoadResults{err}
	mmCacheLoad.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCacheLoad.mock
}

// Set uses given function f to mock the RedisCacheInterface.CacheLoad method
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) Set(f func(ctx context.Context, limit int) (err error)) *RedisCacheInterfaceMock {
	if mmCacheLoad.defaultExpectation != nil {
		mmCacheLoad.mock.t.Fatalf("Default expectation is already set for the RedisCacheInterface.CacheLoad method")
	}

	if len(mmCacheLoad.expectations) > 0 {
		mmCacheLoad.mock.t.Fatalf("Some expectations are already set for the RedisCacheInterface.CacheLoad method")
	}

	mmCacheLoad.mock.funcCacheLoad = f
	mmCacheLoad.mock.funcCacheLoadOrigin = minimock.CallerInfo(1)
	return mmCacheLoad.mock
}

// When sets expectation for the RedisCacheInterface.CacheLoad which will trigger the result defined by the following
// Then helper
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) When(ctx context.Context, limit int) *RedisCacheInterfaceMockCacheLoadExpectation {
	if mmCacheLoad.mock.funcCacheLoad != nil {
		mmCacheLoad.mock.t.Fatalf("RedisCacheInterfaceMock.CacheLoad mock is already set by Set")
	}

	expectation := &RedisCacheInterfaceMockCacheLoadExpectation{
		mock:               mmCacheLoad.mock,
		params:             &RedisCacheInterfaceMockCacheLoadParams{ctx, limit},
		expectationOrigins: RedisCacheInterfaceMockCacheLoadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCacheLoad.expectations = append(mmCacheLoad.expectations, expectation)
	return expectation
}

// Then sets up RedisCacheInterface.CacheLoad return parameters for the expectation previously defined by the When method
func (e *RedisCacheInterfaceMockCacheLoadExpectation) Then(err error) *RedisCacheInterfaceMock {
	e.results = &RedisCacheInterfaceMockCacheLoadResults{err}
	return e.mock
}

// Times sets number of times RedisCacheInterface.CacheLoad should be invoked
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) Times(n uint64) *mRedisCacheInterfaceMockCacheLoad {
	if n == 0 {
		mmCacheLoad.mock.t.Fatalf("Times of RedisCacheInterfaceMock.CacheLoad mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCacheLoad.expectedInvocations, n)
	mmCacheLoad.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCacheLoad
}

func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) invocationsDone() bool {
	if len(mmCacheLoad.expectations) == 0 && mmCacheLoad.defaultExpectation == nil && mmCacheLoad.mock.funcCacheLoad == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCacheLoad.mock.afterCacheLoadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCacheLoad.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CacheLoad implements mm_cache.RedisCacheInterface
func (mmCacheLoad *RedisCacheInterfaceMock) CacheLoad(ctx context.Context, limit int) (err error) {
	mm_atomic.AddUint64(&mmCacheLoad.beforeCacheLoadCounter, 1)
	defer mm_atomic.AddUint64(&mmCacheLoad.afterCacheLoadCounter, 1)

	mmCacheLoad.t.Helper()

	if mmCacheLoad.inspectFuncCacheLoad != nil {
		mmCacheLoad.inspectFuncCacheLoad(ctx, limit)
	}

	mm_params := RedisCacheInterfaceMockCacheLoadParams{ctx, limit}

	// Record call args
	mmCacheLoad.CacheLoadMock.mutex.Lock()
	mmCacheLoad.CacheLoadMock.callArgs = append(mmCacheLoad.CacheLoadMock.callArgs, &mm_params)
	mmCacheLoad.CacheLoadMock.mutex.Unlock()

	for _, e := range mmCacheLoad.CacheLoadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCacheLoad.CacheLoadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCacheLoad.CacheLoadMock.defaultExpectation.Counter, 1)
		mm_want := mmCacheLoad.CacheLoadMock.defaultExpectation.params
		mm_want_ptrs := mmCacheLoad.CacheLoadMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheInterfaceMockCacheLoadParams{ctx, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCacheLoad.t.Errorf("RedisCacheInterfaceMock.CacheLoad got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCacheLoad.CacheLoadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmCacheLoad.t.Errorf("RedisCacheInterfaceMock.CacheLoad got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCacheLoad.CacheLoadMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCacheLoad.t.Errorf("RedisCacheInterfaceMock.CacheLoad got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCacheLoad.CacheLoadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCacheLoad.CacheLoadMock.defaultExpectation.results
		if mm_results == nil {
			mmCacheLoad.t.Fatal("No results are set for the RedisCacheInterfaceMock.CacheLoad")
		}
		return (*mm_results).err
	}
	if mmCacheLoad.funcCacheLoad != nil {
		return mmCacheLoad.funcCacheLoad(ctx, limit)
	}
	mmCacheLoad.t.Fatalf("Unexpected call to RedisCacheInterfaceMock.CacheLoad. %v %v", ctx, limit)
	return
}

// CacheLoadAfterCounter returns a count of finished RedisCacheInterfaceMock.CacheLoad invocations
func (mmCacheLoad *RedisCacheInterfaceMock) CacheLoadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCacheLoad.afterCacheLoadCounter)
}

// CacheLoadBeforeCounter returns a count of RedisCacheInterfaceMock.CacheLoad invocations
func (mmCacheLoad *RedisCacheInterfaceMock) CacheLoadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCacheLoad.beforeCacheLoadCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheInterfaceMock.CacheLoad.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCacheLoad *mRedisCacheInterfaceMockCacheLoad) Calls() []*RedisCacheInterfaceMockCacheLoadParams {
	mmCacheLoad.mutex.RLock()

	argCopy := make([]*RedisCacheInterfaceMockCacheLoadParams, len(mmCacheLoad.callArgs))
	copy(argCopy, mmCacheLoad.callArgs)

	mmCacheLoad.mutex.RUnlock()

	return argCopy
}

// MinimockCacheLoadDone returns true if the count of the CacheLoad invocations corresponds
// the number of defined expectations
func (m *RedisCacheInterfaceMock) MinimockCacheLoadDone() bool {
	if m.CacheLoadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CacheLoadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CacheLoadMock.invocationsDone()
}

// MinimockCacheLoadInspect logs each unmet expectation
func (m *RedisCacheInterfaceMock) MinimockCacheLoadInspect() {
	for _, e := range m.CacheLoadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.CacheLoad at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCacheLoadCounter := mm_atomic.LoadUint64(&m.afterCacheLoadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CacheLoadMock.defaultExpectation != nil && afterCacheLoadCounter < 1 {
		if m.CacheLoadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.CacheLoad at\n%s", m.CacheLoadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.CacheLoad at\n%s with params: %#v", m.CacheLoadMock.defaultExpectation.expectationOrigins.origin, *m.CacheLoadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCacheLoad != nil && afterCacheLoadCounter < 1 {
		m.t.Errorf("Expected call to RedisCacheInterfaceMock.CacheLoad at\n%s", m.funcCacheLoadOrigin)
	}

	if !m.CacheLoadMock.invocationsDone() && afterCacheLoadCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheInterfaceMock.CacheLoad at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CacheLoadMock.expectedInvocations), m.CacheLoadMock.expectedInvocationsOrigin, afterCacheLoadCounter)
	}
}

type mRedisCacheInterfaceMockReadFromCache struct {
	optional           bool
	mock               *RedisCacheInterfaceMock
	defaultExpectation *RedisCacheInterfaceMockReadFromCacheExpectation
	expectations       []*RedisCacheInterfaceMockReadFromCacheExpectation

	callArgs []*RedisCacheInterfaceMockReadFromCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RedisCacheInterfaceMockReadFromCacheExpectation specifies expectation struct of the RedisCacheInterface.ReadFromCache
type RedisCacheInterfaceMockReadFromCacheExpectation struct {
	mock               *RedisCacheInterfaceMock
	params             *RedisCacheInterfaceMockReadFromCacheParams
	paramPtrs          *RedisCacheInterfaceMockReadFromCacheParamPtrs
	expectationOrigins RedisCacheInterfaceMockReadFromCacheExpectationOrigins
	results            *RedisCacheInterfaceMockReadFromCacheResults
	returnOrigin       string
	Counter            uint64
}

// RedisCacheInterfaceMockReadFromCacheParams contains parameters of the RedisCacheInterface.ReadFromCache
type RedisCacheInterfaceMockReadFromCacheParams struct {
	ctx context.Context
	uid string
}

// RedisCacheInterfaceMockReadFromCacheParamPtrs contains pointers to parameters of the RedisCacheInterface.ReadFromCache
type RedisCacheInterfaceMockReadFromCacheParamPtrs struct {
	ctx *context.Context
	uid *string
}

// RedisCacheInterfaceMockReadFromCacheResults contains results of the RedisCacheInterface.ReadFromCache
type RedisCacheInterfaceMockReadFromCacheResults struct {
	reply model.Reply
	err   error
}

// RedisCacheInterfaceMockReadFromCacheOrigins contains origins of expectations of the RedisCacheInterface.ReadFromCache
type RedisCacheInterfaceMockReadFromCacheExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) Optional() *mRedisCacheInterfaceMockReadFromCache {
	mmReadFromCache.optional = true
	return mmReadFromCache
}

// Expect sets up expected params for RedisCacheInterface.ReadFromCache
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) Expect(ctx context.Context, uid string) *mRedisCacheInterfaceMockReadFromCache {
	if mmReadFromCache.mock.funcReadFromCache != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by Set")
	}

	if mmReadFromCache.defaultExpectation == nil {
		mmReadFromCache.defaultExpectation = &RedisCacheInterfaceMockReadFromCacheExpectation{}
	}

	if mmReadFromCache.defaultExpectation.paramPtrs != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by ExpectParams functions")
	}

	mmReadFromCache.defaultExpectation.params = &RedisCacheInterfaceMockReadFromCacheParams{ctx, uid}
	mmReadFromCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadFromCache.expectations {
		if minimock.Equal(e.params, mmReadFromCache.defaultExpectation.params) {
			mmReadFromCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadFromCache.defaultExpectation.params)
		}
	}

	return mmReadFromCache
}

// ExpectCtxParam1 sets up expected param ctx for RedisCacheInterface.ReadFromCache
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) ExpectCtxParam1(ctx context.Context) *mRedisCacheInterfaceMockReadFromCache {
	if mmReadFromCache.mock.funcReadFromCache != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by Set")
	}

	if mmReadFromCache.defaultExpectation == nil {
		mmReadFromCache.defaultExpectation = &RedisCacheInterfaceMockReadFromCacheExpectation{}
	}

	if mmReadFromCache.defaultExpectation.params != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by Expect")
	}

	if mmReadFromCache.defaultExpectation.paramPtrs == nil {
		mmReadFromCache.defaultExpectation.paramPtrs = &RedisCacheInterfaceMockReadFromCacheParamPtrs{}
	}
	mmReadFromCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadFromCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadFromCache
}

// ExpectUidParam2 sets up expected param uid for RedisCacheInterface.ReadFromCache
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) ExpectUidParam2(uid string) *mRedisCacheInterfaceMockReadFromCache {
	if mmReadFromCache.mock.funcReadFromCache != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by Set")
	}

	if mmReadFromCache.defaultExpectation == nil {
		mmReadFromCache.defaultExpectation = &RedisCacheInterfaceMockReadFromCacheExpectation{}
	}

	if mmReadFromCache.defaultExpectation.params != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by Expect")
	}

	if mmReadFromCache.defaultExpectation.paramPtrs == nil {
		mmReadFromCache.defaultExpectation.paramPtrs = &RedisCacheInterfaceMockReadFromCacheParamPtrs{}
	}
	mmReadFromCache.defaultExpectation.paramPtrs.uid = &uid
	mmReadFromCache.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmReadFromCache
}

// Inspect accepts an inspector function that has same arguments as the RedisCacheInterface.ReadFromCache
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) Inspect(f func(ctx context.Context, uid string)) *mRedisCacheInterfaceMockReadFromCache {
	if mmReadFromCache.mock.inspectFuncReadFromCache != nil {
		mmReadFromCache.mock.t.Fatalf("Inspect function is already set for RedisCacheInterfaceMock.ReadFromCache")
	}

	mmReadFromCache.mock.inspectFuncReadFromCache = f

	return mmReadFromCache
}

// Return sets up results that will be returned by RedisCacheInterface.ReadFromCache
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) Return(reply model.Reply, err error) *RedisCacheInterfaceMock {
	if mmReadFromCache.mock.funcReadFromCache != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by Set")
	}

	if mmReadFromCache.defaultExpectation == nil {
		mmReadFromCache.defaultExpectation = &RedisCacheInterfaceMockReadFromCacheExpectation{mock: mmReadFromCache.mock}
	}
	mmReadFromCache.defaultExpectation.results = &RedisCacheInterfaceMockReadFromCacheResults{reply, err}
	mmReadFromCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadFromCache.mock
}

// Set uses given function f to mock the RedisCacheInterface.ReadFromCache method
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) Set(f func(ctx context.Context, uid string) (reply model.Reply, err error)) *RedisCacheInterfaceMock {
	if mmReadFromCache.defaultExpectation != nil {
		mmReadFromCache.mock.t.Fatalf("Default expectation is already set for the RedisCacheInterface.ReadFromCache method")
	}

	if len(mmReadFromCache.expectations) > 0 {
		mmReadFromCache.mock.t.Fatalf("Some expectations are already set for the RedisCacheInterface.ReadFromCache method")
	}

	mmReadFromCache.mock.funcReadFromCache = f
	mmReadFromCache.mock.funcReadFromCacheOrigin = minimock.CallerInfo(1)
	return mmReadFromCache.mock
}

// When sets expectation for the RedisCacheInterface.ReadFromCache which will trigger the result defined by the following
// Then helper
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) When(ctx context.Context, uid string) *RedisCacheInterfaceMockReadFromCacheExpectation {
	if mmReadFromCache.mock.funcReadFromCache != nil {
		mmReadFromCache.mock.t.Fatalf("RedisCacheInterfaceMock.ReadFromCache mock is already set by Set")
	}

	expectation := &RedisCacheInterfaceMockReadFromCacheExpectation{
		mock:               mmReadFromCache.mock,
		params:             &RedisCacheInterfaceMockReadFromCacheParams{ctx, uid},
		expectationOrigins: RedisCacheInterfaceMockReadFromCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadFromCache.expectations = append(mmReadFromCache.expectations, expectation)
	return expectation
}

// Then sets up RedisCacheInterface.ReadFromCache return parameters for the expectation previously defined by the When method
func (e *RedisCacheInterfaceMockReadFromCacheExpectation) Then(reply model.Reply, err error) *RedisCacheInterfaceMock {
	e.results = &RedisCacheInterfaceMockReadFromCacheResults{reply, err}
	return e.mock
}

// Times sets number of times RedisCacheInterface.ReadFromCache should be invoked
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) Times(n uint64) *mRedisCacheInterfaceMockReadFromCache {
	if n == 0 {
		mmReadFromCache.mock.t.Fatalf("Times of RedisCacheInterfaceMock.ReadFromCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadFromCache.expectedInvocations, n)
	mmReadFromCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadFromCache
}

func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) invocationsDone() bool {
	if len(mmReadFromCache.expectations) == 0 && mmReadFromCache.defaultExpectation == nil && mmReadFromCache.mock.funcReadFromCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadFromCache.mock.afterReadFromCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadFromCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadFromCache implements mm_cache.RedisCacheInterface
func (mmReadFromCache *RedisCacheInterfaceMock) ReadFromCache(ctx context.Context, uid string) (reply model.Reply, err error) {
	mm_atomic.AddUint64(&mmReadFromCache.beforeReadFromCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmReadFromCache.afterReadFromCacheCounter, 1)

	mmReadFromCache.t.Helper()

	if mmReadFromCache.inspectFuncReadFromCache != nil {
		mmReadFromCache.inspectFuncReadFromCache(ctx, uid)
	}

	mm_params := RedisCacheInterfaceMockReadFromCacheParams{ctx, uid}

	// Record call args
	mmReadFromCache.ReadFromCacheMock.mutex.Lock()
	mmReadFromCache.ReadFromCacheMock.callArgs = append(mmReadFromCache.ReadFromCacheMock.callArgs, &mm_params)
	mmReadFromCache.ReadFromCacheMock.mutex.Unlock()

	for _, e := range mmReadFromCache.ReadFromCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.reply, e.results.err
		}
	}

	if mmReadFromCache.ReadFromCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadFromCache.ReadFromCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmReadFromCache.ReadFromCacheMock.defaultExpectation.params
		mm_want_ptrs := mmReadFromCache.ReadFromCacheMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheInterfaceMockReadFromCacheParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadFromCache.t.Errorf("RedisCacheInterfaceMock.ReadFromCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadFromCache.ReadFromCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmReadFromCache.t.Errorf("RedisCacheInterfaceMock.ReadFromCache got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadFromCache.ReadFromCacheMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadFromCache.t.Errorf("RedisCacheInterfaceMock.ReadFromCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadFromCache.ReadFromCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadFromCache.ReadFromCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmReadFromCache.t.Fatal("No results are set for the RedisCacheInterfaceMock.ReadFromCache")
		}
		return (*mm_results).reply, (*mm_results).err
	}
	if mmReadFromCache.funcReadFromCache != nil {
		return mmReadFromCache.funcReadFromCache(ctx, uid)
	}
	mmReadFromCache.t.Fatalf("Unexpected call to RedisCacheInterfaceMock.ReadFromCache. %v %v", ctx, uid)
	return
}

// ReadFromCacheAfterCounter returns a count of finished RedisCacheInterfaceMock.ReadFromCache invocations
func (mmReadFromCache *RedisCacheInterfaceMock) ReadFromCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFromCache.afterReadFromCacheCounter)
}

// ReadFromCacheBeforeCounter returns a count of RedisCacheInterfaceMock.ReadFromCache invocations
func (mmReadFromCache *RedisCacheInterfaceMock) ReadFromCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFromCache.beforeReadFromCacheCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheInterfaceMock.ReadFromCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadFromCache *mRedisCacheInterfaceMockReadFromCache) Calls() []*RedisCacheInterfaceMockReadFromCacheParams {
	mmReadFromCache.mutex.RLock()

	argCopy := make([]*RedisCacheInterfaceMockReadFromCacheParams, len(mmReadFromCache.callArgs))
	copy(argCopy, mmReadFromCache.callArgs)

	mmReadFromCache.mutex.RUnlock()

	return argCopy
}

// MinimockReadFromCacheDone returns true if the count of the ReadFromCache invocations corresponds
// the number of defined expectations
func (m *RedisCacheInterfaceMock) MinimockReadFromCacheDone() bool {
	if m.ReadFromCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadFromCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadFromCacheMock.invocationsDone()
}

// MinimockReadFromCacheInspect logs each unmet expectation
func (m *RedisCacheInterfaceMock) MinimockReadFromCacheInspect() {
	for _, e := range m.ReadFromCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.ReadFromCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadFromCacheCounter := mm_atomic.LoadUint64(&m.afterReadFromCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadFromCacheMock.defaultExpectation != nil && afterReadFromCacheCounter < 1 {
		if m.ReadFromCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.ReadFromCache at\n%s", m.ReadFromCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RedisCacheInterfaceMock.ReadFromCache at\n%s with params: %#v", m.ReadFromCacheMock.defaultExpectation.expectationOrigins.origin, *m.ReadFromCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadFromCache != nil && afterReadFromCacheCounter < 1 {
		m.t.Errorf("Expected call to RedisCacheInterfaceMock.ReadFromCache at\n%s", m.funcReadFromCacheOrigin)
	}

	if !m.ReadFromCacheMock.invocationsDone() && afterReadFromCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheInterfaceMock.ReadFromCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadFromCacheMock.expectedInvocations), m.ReadFromCacheMock.expectedInvocationsOrigin, afterReadFromCacheCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RedisCacheInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddToCacheInspect()

			m.MinimockCacheLoadInspect()

			m.MinimockReadFromCacheInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RedisCacheInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RedisCacheInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCacheDone() &&
		m.MinimockCacheLoadDone() &&
		m.MinimockReadFromCacheDone()
}
